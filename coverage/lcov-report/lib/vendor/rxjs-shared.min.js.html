
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for lib/vendor/rxjs-shared.min.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../index.html">All files</a> / <a href="index.html">lib/vendor</a> rxjs-shared.min.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">11.71% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>223/1903</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">7.46% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>120/1607</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">9.57% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>87/909</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>1/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">58x</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/* rxjs@7.8.1 */
function e(e){return"function"==typeof e}function t(e){const t=e((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >Error.call(e),e.stack=(new Error).stack}</span>));return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}const n=t((e=&gt;<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >`${t+1}) ${e.toString()}`)</span>).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=t}</span>));function <span class="fstat-no" title="function not covered" >r(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e){const n=<span class="cstat-no" title="statement not covered" >e.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>0&lt;=n&amp;&amp;e.splice(n,1)}</span>}</span>class s{constructor(e){this.initialTeardown=e,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;<span class="missing-if-branch" title="else path not taken" >E</span>if(!this.closed){this.closed=!0;const{_parentage:r}=this;if(r)<span class="missing-if-branch" title="if path not taken" >I</span>if(this._parentage=null,Array.isArray(r))<span class="cstat-no" title="statement not covered" >for(const e of r)<span class="cstat-no" title="statement not covered" >e.remove(this);e</span></span>lse r.remove(this);const{initialTeardown:s}=this;<span class="missing-if-branch" title="if path not taken" >I</span>if(e(s))<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >s()}</span>catch(e){<span class="cstat-no" title="statement not covered" >t=e instanceof n?e.errors:[e]}</span>c</span>onst{_finalizers:o}=this;if(o){this._finalizers=null;for(const e of o)try{c(e)}catch(e){<span class="cstat-no" title="statement not covered" >t=null!=t?t:[],e instanceof n?t=[...t,...e.errors]:t.push(e)}</span>}<span class="missing-if-branch" title="if path not taken" >I</span>if(t)<span class="cstat-no" title="statement not covered" >throw new n(t)}</span>}add(e){var t;if(e&amp;&amp;e!==this)<span class="missing-if-branch" title="if path not taken" >I</span>if(this.closed)<span class="cstat-no" title="statement not covered" >c(e);e</span>lse{<span class="missing-if-branch" title="else path not taken" >E</span>if(e instanceof s){<span class="missing-if-branch" title="if path not taken" >I</span>if(e.closed||e._hasParent(this))<span class="cstat-no" title="statement not covered" >return;e</span>._addParent(this)}(this._finalizers=null!==(t=this._finalizers)&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==t?<span class="branch-0 cbranch-no" title="branch not covered" ></span>t:</span>[]).push(e)}}_hasParent(e){const{_parentage:t}=this;return t===e||Array.isArray(t)&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >t.includes(e)}</span>_addParent(e){const{_parentage:t}=this;this._parentage=Array.isArray(t)?(<span class="branch-0 cbranch-no" title="branch not covered" >t.push(e),t)</span>:t?<span class="branch-0 cbranch-no" title="branch not covered" >[t,e]:</span>e}_removeParent(e){const{_parentage:t}=this;t===e?<span class="branch-0 cbranch-no" title="branch not covered" >this._parentage=null:</span>Array.isArray(t)&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r(t,e)}</span>remove(e){const{_finalizers:t}=this;t&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >r(t,e),</span>e instanceof s&amp;&amp;e._removeParent(this)}}s.EMPTY=(()=&gt;{const e=new s;return e.closed=!0,e})();const o=s.EMPTY;function i(t){return t instanceof s||<span class="branch-1 cbranch-no" title="branch not covered" >t&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >"closed"in t&amp;</span>&amp;<span class="branch-3 cbranch-no" title="branch not covered" >e(t.remove)&amp;</span>&amp;<span class="branch-4 cbranch-no" title="branch not covered" >e(t.add)&amp;</span>&amp;<span class="branch-5 cbranch-no" title="branch not covered" >e(t.unsubscribe)}</span>function c(t){e(t)?<span class="branch-0 cbranch-no" title="branch not covered" >t():</span>t.unsubscribe()}const u={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},l={<span class="fstat-no" title="function not covered" >se</span>tTimeout(e,t,...n){const{delegate:r}=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" ></span>return(null==r?void 0:r.setTimeout)?r.setTimeout(e,t,...n):setTimeout(e,t,...n)}</span>,<span class="fstat-no" title="function not covered" >cl</span>earTimeout(e){const{delegate:t}=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" ></span>return((null==t?void 0:t.clearTimeout)||clearTimeout)(e)}</span>,delegate:void 0};function <span class="fstat-no" title="function not covered" >a(</span>e){<span class="cstat-no" title="statement not covered" >l.setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{const{onUnhandledError:t}=<span class="cstat-no" title="statement not covered" >u;<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >throw e;<span class="cstat-no" title="statement not covered" >t</span></span>(e)}</span>))}</span>function <span class="fstat-no" title="function not covered" >h(</span>){}const f=p("C",void 0,void 0);function <span class="fstat-no" title="function not covered" >d(</span>e){<span class="cstat-no" title="statement not covered" >return p("E",void 0,e)}</span>function <span class="fstat-no" title="function not covered" >b(</span>e){<span class="cstat-no" title="statement not covered" >return p("N",e,void 0)}</span>function p(e,t,n){return{kind:e,value:t,error:n}}let m=null;function v(e){<span class="missing-if-branch" title="if path not taken" >I</span>if(u.useDeprecatedSynchronousErrorHandling){const t=<span class="cstat-no" title="statement not covered" >!m;<span class="cstat-no" title="statement not covered" ></span>if(t&amp;&amp;(m={errorThrown:!1,error:null}),e(),t){const{errorThrown:e,error:t}=<span class="cstat-no" title="statement not covered" >m;<span class="cstat-no" title="statement not covered" ></span>if(m=null,e)<span class="cstat-no" title="statement not covered" >throw t}</span></span>}</span>else e()}class w extends s{constructor(e){super(),this.isStopped=!1,e?(this.destination=e,i(e)&amp;&amp;e.add(this)):this.destination=O}<span class="fstat-no" title="function not covered" >st</span>atic create(e,t,n){<span class="cstat-no" title="statement not covered" >return new g(e,t,n)}</span>next(e){this.isStopped?<span class="branch-0 cbranch-no" title="branch not covered" >E(b(e),this):</span>this._next(e)}error(e){this.isStopped?<span class="branch-0 cbranch-no" title="branch not covered" >E(d(e),this):</span>(this.isStopped=!0,this._error(e))}complete(){this.isStopped?<span class="branch-0 cbranch-no" title="branch not covered" >E(f,this):</span>(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(e){this.destination.next(e)}_error(e){try{this.destination.error(e)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const y=Function.prototype.bind;function <span class="fstat-no" title="function not covered" >x(</span>e,t){<span class="cstat-no" title="statement not covered" >return y.call(e,t)}</span>class _{constructor(e){this.partialObserver=e}next(e){const{partialObserver:t}=this;<span class="missing-if-branch" title="else path not taken" >E</span>if(t.next)try{t.next(e)}catch(e){<span class="cstat-no" title="statement not covered" >S(e)}</span>}error(e){const{partialObserver:t}=this;if(t.error)try{t.error(e)}catch(e){<span class="cstat-no" title="statement not covered" >S(e)}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="else path not taken" >E</span>S(e)}</span>complete(){const{partialObserver:e}=this;<span class="missing-if-branch" title="if path not taken" >I</span>if(e.complete)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >e.complete()}</span>catch(e){<span class="cstat-no" title="statement not covered" >S(e)}</span>}</span>}class g extends w{constructor(t,n,r){let s;if(super(),e(t)||<span class="branch-1 cbranch-no" title="branch not covered" >!t)</span>s={next:null!=t?t:<span class="branch-1 cbranch-no" title="branch not covered" >void 0,</span>error:null!=n?n:<span class="branch-1 cbranch-no" title="branch not covered" >void 0,</span>complete:null!=r?<span class="branch-0 cbranch-no" title="branch not covered" >r:</span>void 0};else<span class="missing-if-branch" title="else path not taken" >E</span>{let e;<span class="cstat-no" title="statement not covered" >this&amp;&amp;u.useDeprecatedNextContext?(e=Object.create(t),e.unsubscribe=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.unsubscribe(),</span>s={next:t.next&amp;&amp;x(t.next,e),error:t.error&amp;&amp;x(t.error,e),complete:t.complete&amp;&amp;x(t.complete,e)}):s=t}</span>this.destination=new _(s)}}function <span class="fstat-no" title="function not covered" >S(</span>e){var t;<span class="cstat-no" title="statement not covered" >u.useDeprecatedSynchronousErrorHandling?(t=e,u.useDeprecatedSynchronousErrorHandling&amp;&amp;m&amp;&amp;(m.errorThrown=!0,m.error=t)):a(e)}</span>function <span class="fstat-no" title="function not covered" >E(</span>e,t){const{onStoppedNotification:n}=<span class="cstat-no" title="statement not covered" >u;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;l.setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n(e,t))</span>)}</span>const O={closed:!0,next:h,error:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >throw e}</span>,complete:h},T="function"==typeof Symbol&amp;&amp;Symbol.observable||"@@observable";function <span class="fstat-no" title="function not covered" >A(</span>e){<span class="cstat-no" title="statement not covered" >return e}</span>function <span class="fstat-no" title="function not covered" >I(</span>...e){<span class="cstat-no" title="statement not covered" >return k(e)}</span>function k(e){return 0===e.length?<span class="branch-0 cbranch-no" title="branch not covered" >A:</span>1===e.length?<span class="branch-0 cbranch-no" title="branch not covered" >e[0]:</span>function(t){return e.reduce(((e,t)=&gt;t(e)),t)}}class j{constructor(e){e&amp;&amp;(this._subscribe=e)}lift(e){const t=new j;return t.source=this,t.operator=e,t}subscribe(t,n,r){const s=(o=t)&amp;&amp;o instanceof w||function(t){return t&amp;&amp;e(t.next)&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >e(t.error)&amp;</span>&amp;<span class="branch-3 cbranch-no" title="branch not covered" >e(t.complete)}</span>(o)&amp;&amp;<span class="branch-3 cbranch-no" title="branch not covered" >i(o)?</span>t:new g(t,n,r);var o;return v((()=&gt;{const{operator:e,source:t}=this;s.add(e?e.call(s,t):t?<span class="branch-0 cbranch-no" title="branch not covered" >this._subscribe(s):</span>this._trySubscribe(s))})),s}_trySubscribe(e){try{return this._subscribe(e)}catch(t){<span class="cstat-no" title="statement not covered" >e.error(t)}</span>}<span class="fstat-no" title="function not covered" >fo</span>rEach(e,t){<span class="cstat-no" title="statement not covered" >return new(t=C(t))((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{const r=<span class="cstat-no" title="statement not covered" >new g({next:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >e(t)}</span>catch(e){<span class="cstat-no" title="statement not covered" >n(e),r.unsubscribe()}</span>}</span>,error:n,complete:t});<span class="cstat-no" title="statement not covered" ></span>this.subscribe(r)}</span>))}<span class="fstat-no" title="function not covered" ></span>_s</span>ubscribe(e){var t;<span class="cstat-no" title="statement not covered" >return null===(t=this.source)||void 0===t?void 0:t.subscribe(e)}<span class="fstat-no" title="function not covered" ></span>[T</span>](){<span class="cstat-no" title="statement not covered" >return this}</span>pipe(...e){return k(e)(this)}<span class="fstat-no" title="function not covered" >to</span>Promise(e){<span class="cstat-no" title="statement not covered" >return new(e=C(e))((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let n;<span class="cstat-no" title="statement not covered" >this.subscribe((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >n=e)</span>,(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t(e))</span>,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e(n))</span>)}</span>))}</span>}function <span class="fstat-no" title="function not covered" >C(</span>e){var t;<span class="cstat-no" title="statement not covered" >return null!==(t=null!=e?e:u.Promise)&amp;&amp;void 0!==t?t:Promise}</span>function P(t){return e(null==t?<span class="branch-0 cbranch-no" title="branch not covered" >void 0:</span>t.lift)}function N(e){return t=&gt;{<span class="missing-if-branch" title="else path not taken" >E</span>if(P(t))return t.lift((function(t){try{return e(t,this)}catch(e){<span class="cstat-no" title="statement not covered" >this.error(e)}</span>}));<span class="cstat-no" title="statement not covered" >throw new TypeError("Unable to lift unknown Observable type")}</span>}function F(e,t,n,r,s){return new q(e,t,n,r,s)}j.create=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new j(e);</span>class q extends w{constructor(e,t,n,r,s,o){super(e),this.onFinalize=s,this.shouldUnsubscribe=o,this._next=t?function(n){try{t(n)}catch(t){<span class="cstat-no" title="statement not covered" >e.error(t)}</span>}:super._next,this._error=r?function(t){try{r(t)}catch(t){e.error(t)}finally{this.unsubscribe()}}:<span class="branch-1 cbranch-no" title="branch not covered" >super._error,</span>this._complete=n?function(){try{n()}catch(t){<span class="cstat-no" title="statement not covered" >e.error(t)}</span>finally{this.unsubscribe()}}:super._complete}unsubscribe(){var e;<span class="missing-if-branch" title="else path not taken" >E</span>if(!this.shouldUnsubscribe||<span class="branch-1 cbranch-no" title="branch not covered" >this.shouldUnsubscribe())</span>{const{closed:t}=this;super.unsubscribe(),!t&amp;&amp;(null===(e=this.onFinalize)||void 0===e||e.call(this))}}}function <span class="fstat-no" title="function not covered" >L(</span>){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let n=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>e._refCount++;c</span>onst r=<span class="cstat-no" title="statement not covered" >F(t,void 0,void 0,void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!e||e._refCount&lt;=0||0&lt;--e._refCount)<span class="cstat-no" title="statement not covered" >return void(n=null);c</span></span>onst r=<span class="cstat-no" title="statement not covered" >e._connection,</span>s=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>n=null,!r||s&amp;&amp;r!==s||r.unsubscribe(),t.unsubscribe()}</span>));<span class="cstat-no" title="statement not covered" ></span>e.subscribe(r),r.closed||(n=e.connect())}</span>))}</span>class R extends j{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >super(),this.source=e,this.subjectFactory=t,this._subject=null,this._refCount=0,this._connection=null,P(e)&amp;&amp;(this.lift=e.lift)}<span class="fstat-no" title="function not covered" ></span>_s</span>ubscribe(e){<span class="cstat-no" title="statement not covered" >return this.getSubject().subscribe(e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tSubject(){const e=<span class="cstat-no" title="statement not covered" >this._subject;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;!e.isStopped||(this._subject=this.subjectFactory()),this._subject}<span class="fstat-no" title="function not covered" ></span>_t</span>eardown(){<span class="cstat-no" title="statement not covered" >this._refCount=0;c</span>onst{_connection:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._subject=this._connection=null,null==e||e.unsubscribe()}<span class="fstat-no" title="function not covered" ></span>co</span>nnect(){let e=<span class="cstat-no" title="statement not covered" >this._connection;<span class="cstat-no" title="statement not covered" ></span>if(!e){<span class="cstat-no" title="statement not covered" >e=this._connection=new s;c</span>onst t=<span class="cstat-no" title="statement not covered" >this.getSubject();<span class="cstat-no" title="statement not covered" ></span>e.add(this.source.subscribe(F(t,void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._teardown(),t.complete()}</span>),(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._teardown(),t.error(e)}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this._teardown())</span>))),e.closed&amp;&amp;(this._connection=null,e=s.EMPTY)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>re</span>fCount(){<span class="cstat-no" title="statement not covered" >return L()(this)}</span>}const z={now:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >(z.delegate||performance).now(),</span>delegate:void 0},U={<span class="fstat-no" title="function not covered" >sc</span>hedule(e){let t=<span class="cstat-no" title="statement not covered" >requestAnimationFrame,</span>n=<span class="cstat-no" title="statement not covered" >cancelAnimationFrame;</span>const{delegate:r}=<span class="cstat-no" title="statement not covered" >U;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(t=r.requestAnimationFrame,n=r.cancelAnimationFrame);c</span>onst o=<span class="cstat-no" title="statement not covered" >t((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >n=void 0,e(t)}</span>));<span class="cstat-no" title="statement not covered" ></span>return new s((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null==n?void 0:n(o))</span>)}</span>,<span class="fstat-no" title="function not covered" >re</span>questAnimationFrame(...e){const{delegate:t}=<span class="cstat-no" title="statement not covered" >U;<span class="cstat-no" title="statement not covered" ></span>return((null==t?void 0:t.requestAnimationFrame)||requestAnimationFrame)(...e)}</span>,<span class="fstat-no" title="function not covered" >ca</span>ncelAnimationFrame(...e){const{delegate:t}=<span class="cstat-no" title="statement not covered" >U;<span class="cstat-no" title="statement not covered" ></span>return((null==t?void 0:t.cancelAnimationFrame)||cancelAnimationFrame)(...e)}</span>,delegate:void 0};function <span class="fstat-no" title="function not covered" >D(</span>e){<span class="cstat-no" title="statement not covered" >return e?H(e):W}</span>function H(e){return new j((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >e||z,</span>r=<span class="cstat-no" title="statement not covered" >n.now();</span>let s=<span class="cstat-no" title="statement not covered" >0;</span>const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.closed||(s=U.requestAnimationFrame((<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >s=0;c</span>onst c=<span class="cstat-no" title="statement not covered" >n.now();<span class="cstat-no" title="statement not covered" ></span>t.next({timestamp:e?c:i,elapsed:c-r}),o()}</span>)))}</span>;<span class="cstat-no" title="statement not covered" ></span>return o(),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s&amp;&amp;U.cancelAnimationFrame(s)}</span>}</span>))}const W=H(),M=t((e=&gt;<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"}</span>));class V extends j{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}<span class="fstat-no" title="function not covered" ></span>li</span>ft(e){const t=<span class="cstat-no" title="statement not covered" >new $(this,this);<span class="cstat-no" title="statement not covered" ></span>return t.operator=e,t}<span class="fstat-no" title="function not covered" ></span>_t</span>hrowIfClosed(){<span class="cstat-no" title="statement not covered" >if(this.closed)<span class="cstat-no" title="statement not covered" >throw new M}<span class="fstat-no" title="function not covered" ></span></span>ne</span>xt(e){<span class="cstat-no" title="statement not covered" >v((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(this._throwIfClosed(),!this.isStopped){<span class="cstat-no" title="statement not covered" >this.currentObservers||(this.currentObservers=Array.from(this.observers));<span class="cstat-no" title="statement not covered" >f</span>or(const t of this.currentObservers)<span class="cstat-no" title="statement not covered" >t.next(e)}</span></span>}</span>))}<span class="fstat-no" title="function not covered" ></span>er</span>ror(e){<span class="cstat-no" title="statement not covered" >v((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(this._throwIfClosed(),!this.isStopped){<span class="cstat-no" title="statement not covered" >this.hasError=this.isStopped=!0,this.thrownError=e;c</span>onst{observers:t}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(;t.length;)<span class="cstat-no" title="statement not covered" >t.shift().error(e)}</span></span>}</span>))}<span class="fstat-no" title="function not covered" ></span>co</span>mplete(){<span class="cstat-no" title="statement not covered" >v((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(this._throwIfClosed(),!this.isStopped){<span class="cstat-no" title="statement not covered" >this.isStopped=!0;c</span>onst{observers:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(;e.length;)<span class="cstat-no" title="statement not covered" >e.shift().complete()}</span></span>}</span>))}<span class="fstat-no" title="function not covered" ></span>un</span>subscribe(){<span class="cstat-no" title="statement not covered" >this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}<span class="fstat-no" title="function not covered" ></span>ge</span>t observed(){var e;<span class="cstat-no" title="statement not covered" >return(null===(e=this.observers)||void 0===e?void 0:e.length)&gt;0}<span class="fstat-no" title="function not covered" ></span>_t</span>rySubscribe(e){<span class="cstat-no" title="statement not covered" >return this._throwIfClosed(),super._trySubscribe(e)}<span class="fstat-no" title="function not covered" ></span>_s</span>ubscribe(e){<span class="cstat-no" title="statement not covered" >return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}<span class="fstat-no" title="function not covered" ></span>_i</span>nnerSubscribe(e){const{hasError:t,isStopped:n,observers:i}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t||n?o:(this.currentObservers=null,i.push(e),new s((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.currentObservers=null,r(i,e)}</span>)))}<span class="fstat-no" title="function not covered" ></span>_c</span>heckFinalizedStatuses(e){const{hasError:t,thrownError:n,isStopped:r}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t?e.error(n):r&amp;&amp;e.complete()}<span class="fstat-no" title="function not covered" ></span>as</span>Observable(){const e=<span class="cstat-no" title="statement not covered" >new j;<span class="cstat-no" title="statement not covered" ></span>return e.source=this,e}</span>}V.create=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >new $(e,t);</span>class $ extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >super(),this.destination=e,this.source=t}<span class="fstat-no" title="function not covered" ></span>ne</span>xt(e){var t,n;<span class="cstat-no" title="statement not covered" >null===(n=null===(t=this.destination)||void 0===t?void 0:t.next)||void 0===n||n.call(t,e)}<span class="fstat-no" title="function not covered" ></span>er</span>ror(e){var t,n;<span class="cstat-no" title="statement not covered" >null===(n=null===(t=this.destination)||void 0===t?void 0:t.error)||void 0===n||n.call(t,e)}<span class="fstat-no" title="function not covered" ></span>co</span>mplete(){var e,t;<span class="cstat-no" title="statement not covered" >null===(t=null===(e=this.destination)||void 0===e?void 0:e.complete)||void 0===t||t.call(e)}<span class="fstat-no" title="function not covered" ></span>_s</span>ubscribe(e){var t,n;<span class="cstat-no" title="statement not covered" >return null!==(n=null===(t=this.source)||void 0===t?void 0:t.subscribe(e))&amp;&amp;void 0!==n?n:o}</span>}class B extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >super(),this._value=e}<span class="fstat-no" title="function not covered" ></span>ge</span>t value(){<span class="cstat-no" title="statement not covered" >return this.getValue()}<span class="fstat-no" title="function not covered" ></span>_s</span>ubscribe(e){const t=<span class="cstat-no" title="statement not covered" >super._subscribe(e);<span class="cstat-no" title="statement not covered" ></span>return!t.closed&amp;&amp;e.next(this._value),t}<span class="fstat-no" title="function not covered" ></span>ge</span>tValue(){const{hasError:e,thrownError:t,_value:n}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >throw t;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._throwIfClosed(),n}<span class="fstat-no" title="function not covered" ></span>ne</span>xt(e){<span class="cstat-no" title="statement not covered" >super.next(this._value=e)}</span>}const X={now:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >(X.delegate||Date).now(),</span>delegate:void 0};class Y extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(e=<span class="branch-0 cbranch-no" title="branch not covered" >1/0,</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >1/0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >X)</span>{<span class="cstat-no" title="statement not covered" >super(),this._bufferSize=e,this._windowTime=t,this._timestampProvider=n,this._buffer=[],this._infiniteTimeWindow=!0,this._infiniteTimeWindow=t===1/0,this._bufferSize=Math.max(1,e),this._windowTime=Math.max(1,t)}<span class="fstat-no" title="function not covered" ></span>ne</span>xt(e){const{isStopped:t,_buffer:n,_infiniteTimeWindow:r,_timestampProvider:s,_windowTime:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t||(n.push(e),!r&amp;&amp;n.push(s.now()+o)),this._trimBuffer(),super.next(e)}<span class="fstat-no" title="function not covered" ></span>_s</span>ubscribe(e){<span class="cstat-no" title="statement not covered" >this._throwIfClosed(),this._trimBuffer();c</span>onst t=<span class="cstat-no" title="statement not covered" >this._innerSubscribe(e),</span>{_infiniteTimeWindow:n,_buffer:r}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >r.slice();<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;s.length&amp;&amp;!e.closed;t+=n?1:2)<span class="cstat-no" title="statement not covered" >e.next(s[t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._checkFinalizedStatuses(e),t}<span class="fstat-no" title="function not covered" ></span>_t</span>rimBuffer(){const{_bufferSize:e,_timestampProvider:t,_buffer:n,_infiniteTimeWindow:r}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >(r?1:2)*e;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;1/0&amp;&amp;s&lt;n.length&amp;&amp;n.splice(0,n.length-s),!r){const e=<span class="cstat-no" title="statement not covered" >t.now();</span>let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >1;</span>t&lt;n.length&amp;&amp;n[t]&lt;=e;t+=2)<span class="cstat-no" title="statement not covered" >r=t;<span class="cstat-no" title="statement not covered" >r</span></span>&amp;&amp;n.splice(0,r+1)}</span>}</span>}class J extends V{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this._value=null,this._hasValue=!1,this._isComplete=!1}<span class="fstat-no" title="function not covered" ></span>_c</span>heckFinalizedStatuses(e){const{hasError:t,_hasValue:n,_value:r,thrownError:s,isStopped:o,_isComplete:i}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t?e.error(s):(o||i)&amp;&amp;(n&amp;&amp;e.next(r),e.complete())}<span class="fstat-no" title="function not covered" ></span>ne</span>xt(e){<span class="cstat-no" title="statement not covered" >this.isStopped||(this._value=e,this._hasValue=!0)}<span class="fstat-no" title="function not covered" ></span>co</span>mplete(){const{_hasValue:e,_value:t,_isComplete:n}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>n||(this._isComplete=!0,e&amp;&amp;super.next(t),super.complete())}</span>}class G extends s{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >super()}<span class="fstat-no" title="function not covered" ></span>sc</span>hedule(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return this}</span>}const Z={<span class="fstat-no" title="function not covered" >se</span>tInterval(e,t,...n){const{delegate:r}=<span class="cstat-no" title="statement not covered" >Z;<span class="cstat-no" title="statement not covered" ></span>return(null==r?void 0:r.setInterval)?r.setInterval(e,t,...n):setInterval(e,t,...n)}</span>,<span class="fstat-no" title="function not covered" >cl</span>earInterval(e){const{delegate:t}=<span class="cstat-no" title="statement not covered" >Z;<span class="cstat-no" title="statement not covered" ></span>return((null==t?void 0:t.clearInterval)||clearInterval)(e)}</span>,delegate:void 0};class K extends G{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >super(e,t),this.scheduler=e,this.work=t,this.pending=!1}<span class="fstat-no" title="function not covered" ></span>sc</span>hedule(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{var n;<span class="cstat-no" title="statement not covered" >if(this.closed)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >t</span></span>his.state=e;c</span>onst r=<span class="cstat-no" title="statement not covered" >this.id,</span>s=<span class="cstat-no" title="statement not covered" >this.scheduler;<span class="cstat-no" title="statement not covered" ></span>return null!=r&amp;&amp;(this.id=this.recycleAsyncId(s,r,t)),this.pending=!0,this.delay=t,this.id=null!==(n=this.id)&amp;&amp;void 0!==n?n:this.requestAsyncId(s,this.id,t),this}<span class="fstat-no" title="function not covered" ></span>re</span>questAsyncId(e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return Z.setInterval(e.flush.bind(e,this),n)}<span class="fstat-no" title="function not covered" ></span>re</span>cycleAsyncId(e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >if(null!=n&amp;&amp;this.delay===n&amp;&amp;!1===this.pending)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >n</span></span>ull!=t&amp;&amp;Z.clearInterval(t)}<span class="fstat-no" title="function not covered" ></span>ex</span>ecute(e,t){<span class="cstat-no" title="statement not covered" >if(this.closed)<span class="cstat-no" title="statement not covered" >return new Error("executing a cancelled action");<span class="cstat-no" title="statement not covered" >t</span></span>his.pending=!1;c</span>onst n=<span class="cstat-no" title="statement not covered" >this._execute(e,t);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >!</span></span>1===this.pending&amp;&amp;null!=this.id&amp;&amp;(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}<span class="fstat-no" title="function not covered" ></span>_e</span>xecute(e,t){let n,r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >this.work(e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >r=!0,n=e||new Error("Scheduled action threw falsy error")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r)<span class="cstat-no" title="statement not covered" >return this.unsubscribe(),n}<span class="fstat-no" title="function not covered" ></span></span>un</span>subscribe(){<span class="cstat-no" title="statement not covered" >if(!this.closed){const{id:e,scheduler:t}=<span class="cstat-no" title="statement not covered" >this,</span>{actions:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>this.work=this.state=this.scheduler=null,this.pending=!1,r(n,this),null!=e&amp;&amp;(this.id=this.recycleAsyncId(t,e,null)),this.delay=null,super.unsubscribe()}</span>}</span>}let Q,ee=1;const te={};function <span class="fstat-no" title="function not covered" >ne(</span>e){<span class="cstat-no" title="statement not covered" >return e in te&amp;&amp;(delete te[e],!0)}</span>const re={<span class="fstat-no" title="function not covered" >se</span>tImmediate(e){const t=<span class="cstat-no" title="statement not covered" >ee++;<span class="cstat-no" title="statement not covered" ></span>return te[t]=!0,Q||(Q=Promise.resolve()),Q.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ne(t)&amp;&amp;e())</span>),t}</span>,<span class="fstat-no" title="function not covered" >cl</span>earImmediate(e){<span class="cstat-no" title="statement not covered" >ne(e)}</span>},{setImmediate:se,clearImmediate:oe}=re,ie={<span class="fstat-no" title="function not covered" >se</span>tImmediate(...e){const{delegate:t}=<span class="cstat-no" title="statement not covered" >ie;<span class="cstat-no" title="statement not covered" ></span>return((null==t?void 0:t.setImmediate)||se)(...e)}</span>,<span class="fstat-no" title="function not covered" >cl</span>earImmediate(e){const{delegate:t}=<span class="cstat-no" title="statement not covered" >ie;<span class="cstat-no" title="statement not covered" ></span>return((null==t?void 0:t.clearImmediate)||oe)(e)}</span>,delegate:void 0};class ce{constructor(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >ce.now)</span>{this.schedulerActionCtor=e,this.now=t}<span class="fstat-no" title="function not covered" >sc</span>hedule(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n){<span class="cstat-no" title="statement not covered" >return new this.schedulerActionCtor(this,e).schedule(n,t)}</span>}ce.now=X.now;class ue extends ce{constructor(e,t=ce.now){super(e,t),this.actions=[],this._active=!1}<span class="fstat-no" title="function not covered" >fl</span>ush(e){const{actions:t}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this._active)<span class="cstat-no" title="statement not covered" >return void t.push(e);l</span></span>et n;<span class="cstat-no" title="statement not covered" >this._active=!0;<span class="cstat-no" title="statement not covered" >d</span>o{<span class="cstat-no" title="statement not covered" >if(n=e.execute(e.state,e.delay))<span class="cstat-no" title="statement not covered" >break}</span></span>while(e=t.shift());<span class="cstat-no" title="statement not covered" >i</span>f(this._active=!1,n){<span class="cstat-no" title="statement not covered" >for(;e=t.shift();)<span class="cstat-no" title="statement not covered" >e.unsubscribe();<span class="cstat-no" title="statement not covered" >t</span></span>hrow n}</span>}</span>}const le=new class extends ue{<span class="fstat-no" title="function not covered" >fl</span>ush(e){<span class="cstat-no" title="statement not covered" >this._active=!0;c</span>onst t=<span class="cstat-no" title="statement not covered" >this._scheduled;<span class="cstat-no" title="statement not covered" ></span>this._scheduled=void 0;c</span>onst{actions:n}=<span class="cstat-no" title="statement not covered" >this;</span>let r;<span class="cstat-no" title="statement not covered" >e=e||n.shift();<span class="cstat-no" title="statement not covered" >d</span>o{<span class="cstat-no" title="statement not covered" >if(r=e.execute(e.state,e.delay))<span class="cstat-no" title="statement not covered" >break}</span></span>while((e=n[0])&amp;&amp;e.id===t&amp;&amp;n.shift());<span class="cstat-no" title="statement not covered" >i</span>f(this._active=!1,r){<span class="cstat-no" title="statement not covered" >for(;(e=n[0])&amp;&amp;e.id===t&amp;&amp;n.shift();)<span class="cstat-no" title="statement not covered" >e.unsubscribe();<span class="cstat-no" title="statement not covered" >t</span></span>hrow r}</span>}</span>}(class extends K{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >super(e,t),this.scheduler=e,this.work=t}<span class="fstat-no" title="function not covered" ></span>re</span>questAsyncId(e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return null!==n&amp;&amp;n&gt;0?super.requestAsyncId(e,t,n):(e.actions.push(this),e._scheduled||(e._scheduled=ie.setImmediate(e.flush.bind(e,void 0))))}<span class="fstat-no" title="function not covered" ></span>re</span>cycleAsyncId(e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{var r;<span class="cstat-no" title="statement not covered" >if(null!=n?n&gt;0:this.delay&gt;0)<span class="cstat-no" title="statement not covered" >return super.recycleAsyncId(e,t,n);c</span></span>onst{actions:s}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>null!=t&amp;&amp;(null===(r=s[s.length-1])||void 0===r?void 0:r.id)!==t&amp;&amp;(ie.clearImmediate(t),e._scheduled===t&amp;&amp;(e._scheduled=void 0))}</span>}),ae=le,he=new ue(K),fe=he;const de=new class extends ue{}(class extends K{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >super(e,t),this.scheduler=e,this.work=t}<span class="fstat-no" title="function not covered" ></span>sc</span>hedule(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return t&gt;0?super.schedule(e,t):(this.delay=t,this.state=e,this.scheduler.flush(this),this)}<span class="fstat-no" title="function not covered" ></span>ex</span>ecute(e,t){<span class="cstat-no" title="statement not covered" >return t&gt;0||this.closed?super.execute(e,t):this._execute(e,t)}<span class="fstat-no" title="function not covered" ></span>re</span>questAsyncId(e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return null!=n&amp;&amp;n&gt;0||null==n&amp;&amp;this.delay&gt;0?super.requestAsyncId(e,t,n):(e.flush(this),0)}</span>}),be=de;const pe=new class extends ue{<span class="fstat-no" title="function not covered" >fl</span>ush(e){<span class="cstat-no" title="statement not covered" >this._active=!0;c</span>onst t=<span class="cstat-no" title="statement not covered" >this._scheduled;<span class="cstat-no" title="statement not covered" ></span>this._scheduled=void 0;c</span>onst{actions:n}=<span class="cstat-no" title="statement not covered" >this;</span>let r;<span class="cstat-no" title="statement not covered" >e=e||n.shift();<span class="cstat-no" title="statement not covered" >d</span>o{<span class="cstat-no" title="statement not covered" >if(r=e.execute(e.state,e.delay))<span class="cstat-no" title="statement not covered" >break}</span></span>while((e=n[0])&amp;&amp;e.id===t&amp;&amp;n.shift());<span class="cstat-no" title="statement not covered" >i</span>f(this._active=!1,r){<span class="cstat-no" title="statement not covered" >for(;(e=n[0])&amp;&amp;e.id===t&amp;&amp;n.shift();)<span class="cstat-no" title="statement not covered" >e.unsubscribe();<span class="cstat-no" title="statement not covered" >t</span></span>hrow r}</span>}</span>}(class extends K{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >super(e,t),this.scheduler=e,this.work=t}<span class="fstat-no" title="function not covered" ></span>re</span>questAsyncId(e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return null!==n&amp;&amp;n&gt;0?super.requestAsyncId(e,t,n):(e.actions.push(this),e._scheduled||(e._scheduled=U.requestAnimationFrame((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e.flush(void 0))</span>)))}<span class="fstat-no" title="function not covered" ></span>re</span>cycleAsyncId(e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{var r;<span class="cstat-no" title="statement not covered" >if(null!=n?n&gt;0:this.delay&gt;0)<span class="cstat-no" title="statement not covered" >return super.recycleAsyncId(e,t,n);c</span></span>onst{actions:s}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>null!=t&amp;&amp;(null===(r=s[s.length-1])||void 0===r?void 0:r.id)!==t&amp;&amp;(U.cancelAnimationFrame(t),e._scheduled=void 0)}</span>}),me=pe;class ve extends ue{<span class="fstat-no" title="function not covered" >co</span>nstructor(e=<span class="branch-0 cbranch-no" title="branch not covered" >we,</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >1/0)</span>{<span class="cstat-no" title="statement not covered" >super(e,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.frame)</span>),this.maxFrames=t,this.frame=0,this.index=-1}<span class="fstat-no" title="function not covered" ></span>fl</span>ush(){const{actions:e,maxFrames:t}=<span class="cstat-no" title="statement not covered" >this;</span>let n,r;<span class="cstat-no" title="statement not covered" >for(;(r=e[0])&amp;&amp;r.delay&lt;=t&amp;&amp;(e.shift(),this.frame=r.delay,!(n=r.execute(r.state,r.delay))););<span class="cstat-no" title="statement not covered" >i</span>f(n){<span class="cstat-no" title="statement not covered" >for(;r=e.shift();)<span class="cstat-no" title="statement not covered" >r.unsubscribe();<span class="cstat-no" title="statement not covered" >t</span></span>hrow n}</span>}</span>}ve.frameTimeFactor=10;class we extends K{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,n=(<span class="branch-0 cbranch-no" title="branch not covered" >e.index+=1)</span>){<span class="cstat-no" title="statement not covered" >super(e,t),this.scheduler=e,this.work=t,this.index=n,this.active=!0,this.index=e.index=n}<span class="fstat-no" title="function not covered" ></span>sc</span>hedule(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >if(Number.isFinite(t)){<span class="cstat-no" title="statement not covered" >if(!this.id)<span class="cstat-no" title="statement not covered" >return super.schedule(e,t);<span class="cstat-no" title="statement not covered" >t</span></span>his.active=!1;c</span>onst n=<span class="cstat-no" title="statement not covered" >new we(this.scheduler,this.work);<span class="cstat-no" title="statement not covered" ></span>return this.add(n),n.schedule(e,t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.EMPTY}<span class="fstat-no" title="function not covered" ></span>re</span>questAsyncId(e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >this.delay=e.frame+n;c</span>onst{actions:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return r.push(this),r.sort(we.sortActions),1}<span class="fstat-no" title="function not covered" ></span>re</span>cycleAsyncId(e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{}<span class="fstat-no" title="function not covered" >_e</span>xecute(e,t){<span class="cstat-no" title="statement not covered" >if(!0===this.active)<span class="cstat-no" title="statement not covered" >return super._execute(e,t)}<span class="fstat-no" title="function not covered" ></span></span>st</span>atic sortActions(e,t){<span class="cstat-no" title="statement not covered" >return e.delay===t.delay?e.index===t.index?0:e.index&gt;t.index?1:-1:e.delay&gt;t.delay?1:-1}</span>}const ye=new j((e=&gt;e.complete()));function xe(e){return e?<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return new j((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.schedule((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.complete())</span>))</span>)}</span>(e):</span>ye}function _e(t){return t&amp;&amp;e(t.schedule)}function ge(e){return e[e.length-1]}function <span class="fstat-no" title="function not covered" >Se(</span>t){<span class="cstat-no" title="statement not covered" >return e(ge(t))?t.pop():void 0}</span>function Ee(e){return _e(ge(e))?<span class="branch-0 cbranch-no" title="branch not covered" >e.pop():</span>void 0}function <span class="fstat-no" title="function not covered" >Oe(</span>e,t){<span class="cstat-no" title="statement not covered" >return"number"==typeof ge(e)?e.pop():t}</span>function <span class="fstat-no" title="function not covered" >Te(</span>e,t,n,r){<span class="cstat-no" title="statement not covered" >return new(n||(n=Promise))((<span class="fstat-no" title="function not covered" >fu</span>nction(s,o){function <span class="fstat-no" title="function not covered" >i(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >u(r.next(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >c(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >u(r.throw(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >u(</span>e){var t;<span class="cstat-no" title="statement not covered" >e.done?s(e.value):(t=e.value,t instanceof n?t:new n((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e(t)}</span>))).then(i,c)}<span class="cstat-no" title="statement not covered" ></span>u((r=r.apply(e,t||[])).next())}</span>))}</span>function <span class="fstat-no" title="function not covered" >Ae(</span>e){var t=<span class="cstat-no" title="statement not covered" >"function"==typeof Symbol&amp;&amp;Symbol.iterator,</span>n=<span class="cstat-no" title="statement not covered" >t&amp;&amp;e[t],</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return n.call(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(e&amp;&amp;"number"==typeof e.length)<span class="cstat-no" title="statement not covered" >return{next:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;r&gt;=e.length&amp;&amp;(e=void 0),{value:e&amp;&amp;e[r++],done:!e}}</span>};<span class="cstat-no" title="statement not covered" >t</span></span>hrow new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}</span>function <span class="fstat-no" title="function not covered" >Ie(</span>e){<span class="cstat-no" title="statement not covered" >return this instanceof Ie?(this.v=e,this):new Ie(e)}</span>function <span class="fstat-no" title="function not covered" >ke(</span>e,t,n){<span class="cstat-no" title="statement not covered" >if(!Symbol.asyncIterator)<span class="cstat-no" title="statement not covered" >throw new TypeError("Symbol.asyncIterator is not defined.");v</span></span>ar r,s=<span class="cstat-no" title="statement not covered" >n.apply(e,t||[]),</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return r={},i("next"),i("throw"),i("return"),r[Symbol.asyncIterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,r;f</span>unction <span class="fstat-no" title="function not covered" >i(</span>e){<span class="cstat-no" title="statement not covered" >s[e]&amp;&amp;(r[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){<span class="cstat-no" title="statement not covered" >o.push([e,t,n,r])&gt;1||c(e,t)}</span>))}</span>)}</span>function <span class="fstat-no" title="function not covered" >c(</span>e,t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >(n=s[e](t)).value instanceof Ie?Promise.resolve(n.value.v).then(u,l):a(o[0][2],n)}</span>catch(e){<span class="cstat-no" title="statement not covered" >a(o[0][3],e)}</span>v</span>ar n}function <span class="fstat-no" title="function not covered" >u(</span>e){<span class="cstat-no" title="statement not covered" >c("next",e)}</span>function <span class="fstat-no" title="function not covered" >l(</span>e){<span class="cstat-no" title="statement not covered" >c("throw",e)}</span>function <span class="fstat-no" title="function not covered" >a(</span>e,t){<span class="cstat-no" title="statement not covered" >e(t),o.shift(),o.length&amp;&amp;c(o[0][0],o[0][1])}</span>}function <span class="fstat-no" title="function not covered" >je(</span>e){<span class="cstat-no" title="statement not covered" >if(!Symbol.asyncIterator)<span class="cstat-no" title="statement not covered" >throw new TypeError("Symbol.asyncIterator is not defined.");v</span></span>ar t,n=<span class="cstat-no" title="statement not covered" >e[Symbol.asyncIterator];<span class="cstat-no" title="statement not covered" ></span>return n?n.call(e):(e=Ae(e),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,t);f</span>unction <span class="fstat-no" title="function not covered" >r(</span>n){<span class="cstat-no" title="statement not covered" >t[n]=e[n]&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(r,s){<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n,r){<span class="cstat-no" title="statement not covered" >Promise.resolve(r).then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e({value:t,done:n})}</span>),t)}</span>)(r,s,(t=e[n](t)).done,t.value)}</span>))}</span>}</span>}const Ce=e=&gt;e&amp;&amp;"number"==typeof e.length&amp;&amp;"function"!=typeof e;function <span class="fstat-no" title="function not covered" >Pe(</span>t){<span class="cstat-no" title="statement not covered" >return e(null==t?void 0:t.then)}</span>function Ne(t){return e(t[T])}function <span class="fstat-no" title="function not covered" >Fe(</span>t){<span class="cstat-no" title="statement not covered" >return Symbol.asyncIterator&amp;&amp;e(null==t?void 0:t[Symbol.asyncIterator])}</span>function qe(e){return new TypeError(`You provided ${null!==e&amp;&amp;"object"==typeof e?<span class="branch-0 cbranch-no" title="branch not covered" >"an invalid object":</span>`'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const Le="function"==typeof Symbol&amp;&amp;Symbol.iterator?Symbol.iterator:<span class="branch-1 cbranch-no" title="branch not covered" >"@@iterator";</span>function <span class="fstat-no" title="function not covered" >Re(</span>t){<span class="cstat-no" title="statement not covered" >return e(null==t?void 0:t[Le])}</span>function <span class="fstat-no" title="function not covered" >ze(</span>e){<span class="cstat-no" title="statement not covered" >return ke(this,arguments,(<span class="fstat-no" title="function not covered" >fu</span>nction*(){const t=<span class="cstat-no" title="statement not covered" >e.getReader();<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >for(;;){const{value:e,done:n}=<span class="cstat-no" title="statement not covered" >yield Ie(t.read());<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return yield Ie(void 0);<span class="cstat-no" title="statement not covered" >y</span></span>ield yield Ie(e)}</span>}</span>finally{<span class="cstat-no" title="statement not covered" >t.releaseLock()}</span>}</span>))}</span>function <span class="fstat-no" title="function not covered" >Ue(</span>t){<span class="cstat-no" title="statement not covered" >return e(null==t?void 0:t.getReader)}</span>function De(t){<span class="missing-if-branch" title="if path not taken" >I</span>if(t instanceof j)<span class="cstat-no" title="statement not covered" >return t;i</span>f(null!=t){<span class="missing-if-branch" title="if path not taken" >I</span>if(Ne(t))<span class="cstat-no" title="statement not covered" >return o=t,new j((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >o[T]();<span class="cstat-no" title="statement not covered" ></span>if(e(n.subscribe))<span class="cstat-no" title="statement not covered" >return n.subscribe(t);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new TypeError("Provided object does not correctly implement Symbol.observable")}</span>));<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(Ce(t))return s=t,new j((e=&gt;{for(let t=0;t&lt;s.length&amp;&amp;!e.closed;t++)e.next(s[t]);e.complete()}));<span class="cstat-no" title="statement not covered" >if(Pe(t))<span class="cstat-no" title="statement not covered" >return r=t,new j((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.then((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.closed||(e.next(t),e.complete())}</span>),(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.error(t))</span>).then(null,a)}</span>));<span class="cstat-no" title="statement not covered" >i</span></span>f(Fe(t))<span class="cstat-no" title="statement not covered" >return He(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(Re(t))<span class="cstat-no" title="statement not covered" >return n=t,new j((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(const t of n)<span class="cstat-no" title="statement not covered" >if(e.next(t),e.closed)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span></span>.complete()}</span>));<span class="cstat-no" title="statement not covered" >i</span></span>f(Ue(t))<span class="cstat-no" title="statement not covered" >return He(ze(t))}</span></span>var n,r,s,o;throw qe(t)}function <span class="fstat-no" title="function not covered" >He(</span>e){<span class="cstat-no" title="statement not covered" >return new j((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var n,r,s,o;<span class="cstat-no" title="statement not covered" >return Te(this,void 0,void 0,(<span class="fstat-no" title="function not covered" >fu</span>nction*(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >for(n=je(e);!(r=yield n.next()).done;){const e=<span class="cstat-no" title="statement not covered" >r.value;<span class="cstat-no" title="statement not covered" ></span>if(t.next(e),t.closed)<span class="cstat-no" title="statement not covered" >return}</span></span>}</span>catch(e){<span class="cstat-no" title="statement not covered" >s={error:e}}</span>finally{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r&amp;&amp;!r.done&amp;&amp;(o=n.return)&amp;&amp;(yield o.call(n))}</span>finally{<span class="cstat-no" title="statement not covered" >if(s)<span class="cstat-no" title="statement not covered" >throw s.error}</span></span>}<span class="cstat-no" title="statement not covered" ></span>t</span>.complete()}</span>))}</span>)(e,t).catch((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.error(e))</span>)}</span>))}</span>function <span class="fstat-no" title="function not covered" >We(</span>e,t,n,r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{const o=<span class="cstat-no" title="statement not covered" >t.schedule((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n(),s?e.add(this.schedule(null,r)):this.unsubscribe()}</span>),r);<span class="cstat-no" title="statement not covered" ></span>if(e.add(o),!s)<span class="cstat-no" title="statement not covered" >return o}</span></span>function <span class="fstat-no" title="function not covered" >Me(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >n.subscribe(F(r,(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >We(r,e,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r.next(n))</span>,t))</span>,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >We(r,e,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r.complete())</span>,t))</span>,(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >We(r,e,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r.error(n))</span>,t))</span>))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Ve(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >r.add(e.schedule((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n.subscribe(r))</span>,t))}</span>))}</span>function <span class="fstat-no" title="function not covered" >$e(</span>t,n){<span class="cstat-no" title="statement not covered" >return new j((<span class="fstat-no" title="function not covered" >r=</span>&gt;{let s;<span class="cstat-no" title="statement not covered" >return We(r,n,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s=t[Le](),We(r,n,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{let e,t;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >({value:e,done:t}=s.next())}</span>catch(e){<span class="cstat-no" title="statement not covered" >return void r.error(e)}<span class="cstat-no" title="statement not covered" ></span>t</span>?r.complete():r.next(e)}</span>),0,!0)}</span>)),<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e(null==s?void 0:s.return)&amp;&amp;s.return()}</span></span>))}</span>function <span class="fstat-no" title="function not covered" >Be(</span>e,t){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >throw new Error("Iterable cannot be null");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new j((<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >We(n,t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const r=<span class="cstat-no" title="statement not covered" >e[Symbol.asyncIterator]();<span class="cstat-no" title="statement not covered" ></span>We(n,t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.next().then((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.done?n.complete():n.next(e.value)}</span>))}</span>),0,!0)}</span>))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Xe(</span>e,t){<span class="cstat-no" title="statement not covered" >if(null!=e){<span class="cstat-no" title="statement not covered" >if(Ne(e))<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return De(e).pipe(Ve(t),Me(t))}</span>(e,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(Ce(e))<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return new j((<span class="fstat-no" title="function not covered" >n=</span>&gt;{let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t.schedule((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >r===e.length?n.complete():(n.next(e[r++]),n.closed||this.schedule())}</span>))}</span>))}</span>(e,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(Pe(e))<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return De(e).pipe(Ve(t),Me(t))}</span>(e,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(Fe(e))<span class="cstat-no" title="statement not covered" >return Be(e,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(Re(e))<span class="cstat-no" title="statement not covered" >return $e(e,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(Ue(e))<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return Be(ze(e),t)}</span>(e,t)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>hrow qe(e)}</span>function Ye(e,t){return t?<span class="branch-0 cbranch-no" title="branch not covered" >Xe(e,t):</span>De(e)}function Je(...e){return Ye(e,Ee(e))}function Ge(t,n){const r=e(t)?<span class="branch-0 cbranch-no" title="branch not covered" >t:</span>()=&gt;t,s=e=&gt;e.error(r());return new j(n?<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >n.schedule(s,0,e):</span></span>s)}var Ze;!function(e){e.NEXT="N",e.ERROR="E",e.COMPLETE="C"}(Ze||(Ze={}));class Ke{constructor(e,t,n){this.kind=e,this.value=t,this.error=n,this.hasValue="N"===e}<span class="fstat-no" title="function not covered" >ob</span>serve(e){<span class="cstat-no" title="statement not covered" >return Qe(this,e)}<span class="fstat-no" title="function not covered" ></span>do</span>(e,t,n){const{kind:r,value:s,error:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return"N"===r?null==e?void 0:e(s):"E"===r?null==t?void 0:t(o):null==n?void 0:n()}<span class="fstat-no" title="function not covered" ></span>ac</span>cept(t,n,r){var s;<span class="cstat-no" title="statement not covered" >return e(null===(s=t)||void 0===s?void 0:s.next)?this.observe(t):this.do(t,n,r)}<span class="fstat-no" title="function not covered" ></span>to</span>Observable(){const{kind:e,value:t,error:n}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >"N"===e?Je(t):"E"===e?Ge((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n)</span>):"C"===e?ye:0;<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >throw new TypeError(`Unexpected notification kind ${e}`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="fstat-no" title="function not covered" ></span>st</span>atic createNext(e){<span class="cstat-no" title="statement not covered" >return new Ke("N",e)}<span class="fstat-no" title="function not covered" ></span>st</span>atic createError(e){<span class="cstat-no" title="statement not covered" >return new Ke("E",void 0,e)}<span class="fstat-no" title="function not covered" ></span>st</span>atic createComplete(){<span class="cstat-no" title="statement not covered" >return Ke.completeNotification}</span>}function <span class="fstat-no" title="function not covered" >Qe(</span>e,t){var n,r,s;const{kind:o,value:i,error:c}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if("string"!=typeof o)<span class="cstat-no" title="statement not covered" >throw new TypeError('Invalid notification, missing "kind"');<span class="cstat-no" title="statement not covered" >"</span></span>N"===o?null===(n=t.next)||void 0===n||n.call(t,i):"E"===o?null===(r=t.error)||void 0===r||r.call(t,c):null===(s=t.complete)||void 0===s||s.call(t)}</span>function <span class="fstat-no" title="function not covered" >et(</span>t){<span class="cstat-no" title="statement not covered" >return!!t&amp;&amp;(t instanceof j||e(t.lift)&amp;&amp;e(t.subscribe))}</span>Ke.completeNotification=new Ke("C");const tt=t((e=&gt;<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e(this),this.name="EmptyError",this.message="no elements in sequence"}</span>));function <span class="fstat-no" title="function not covered" >nt(</span>e,t){const n=<span class="cstat-no" title="statement not covered" >"object"==typeof t;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >(r</span>,s)=&gt;{let o,i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>e.subscribe({next:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >o=e,i=!0}</span>,error:s,complete:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i?r(o):n?r(t.defaultValue):s(new tt)}</span>})}</span>))}</span>function <span class="fstat-no" title="function not covered" >rt(</span>e,t){const n=<span class="cstat-no" title="statement not covered" >"object"==typeof t;<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >(r</span>,s)=&gt;{const o=<span class="cstat-no" title="statement not covered" >new g({next:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r(e),o.unsubscribe()}</span>,error:s,complete:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n?r(t.defaultValue):s(new tt)}</span>});<span class="cstat-no" title="statement not covered" ></span>e.subscribe(o)}</span>))}</span>const st=t((e=&gt;<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e(this),this.name="ArgumentOutOfRangeError",this.message="argument out of range"}</span>)),ot=t((e=&gt;<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e(this),this.name="NotFoundError",this.message=t}</span>)),it=t((e=&gt;<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e(this),this.name="SequenceError",this.message=t}</span>));function <span class="fstat-no" title="function not covered" >ct(</span>e){<span class="cstat-no" title="statement not covered" >return e instanceof Date&amp;&amp;!isNaN(e)}</span>const ut=t((e=&gt;<span class="fstat-no" title="function not covered" >fu</span>nction(t=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >e(this),this.message="Timeout has occurred",this.name="TimeoutError",this.info=t}</span>));function <span class="fstat-no" title="function not covered" >lt(</span>e,t){const{first:n,each:r,with:s=<span class="branch-0 cbranch-no" title="branch not covered" >at,</span>scheduler:o=(<span class="branch-0 cbranch-no" title="branch not covered" >null!=t?t:he)</span>,meta:i=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>=<span class="cstat-no" title="statement not covered" >ct(e)?{first:e}:"number"==typeof e?{each:e}:e;<span class="cstat-no" title="statement not covered" ></span>if(null==n&amp;&amp;null==r)<span class="cstat-no" title="statement not covered" >throw new TypeError("No timeout provided.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn N((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let c,u,l=<span class="cstat-no" title="statement not covered" >null,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>const h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >u=We(t,o,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >c.unsubscribe(),De(s({meta:i,lastValue:l,seen:a})).subscribe(t)}</span>catch(e){<span class="cstat-no" title="statement not covered" >t.error(e)}</span>}</span>),e)}</span>;<span class="cstat-no" title="statement not covered" ></span>c=e.subscribe(F(t,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >null==u||u.unsubscribe(),a++,t.next(l=e),r&gt;0&amp;&amp;h(r)}</span>),void 0,void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >(null==u?void 0:u.closed)||null==u||u.unsubscribe(),l=null}</span>))),!a&amp;&amp;h(null!=n?"number"==typeof n?n:+n-o.now():r)}</span>))}</span>function <span class="fstat-no" title="function not covered" >at(</span>e){<span class="cstat-no" title="statement not covered" >throw new ut(e)}</span>function ht(e,t){return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>n.subscribe(F(r,(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.next(e.call(t,n,s++))}</span>)))}</span>))}const{isArray:ft}=Array;function <span class="fstat-no" title="function not covered" >dt(</span>e){<span class="cstat-no" title="statement not covered" >return ht((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return ft(t)?e(...t):e(t)}</span>(e,t))</span>)}</span>function <span class="fstat-no" title="function not covered" >bt(</span>e,t,n,r){<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >if(!_e(n))<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(...s){<span class="cstat-no" title="statement not covered" >return bt(e,t,r).apply(this,s).pipe(dt(n))}</span>;<span class="cstat-no" title="statement not covered" >r</span></span>=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r?<span class="fstat-no" title="function not covered" >fu</span>nction(...n){<span class="cstat-no" title="statement not covered" >return bt(e,t).apply(this,n).pipe(Ve(r),Me(r))}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(...n){const r=<span class="cstat-no" title="statement not covered" >new J;</span>let s=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>return new j((<span class="fstat-no" title="function not covered" >o=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >r.subscribe(o);<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >s=!1;l</span>et o=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.apply(this,[...n,<span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;{<span class="cstat-no" title="statement not covered" >if(e){const e=<span class="cstat-no" title="statement not covered" >t.shift();<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >return void r.error(e)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>.next(1&lt;t.length?t:t[0]),i=!0,o&amp;&amp;r.complete()}</span>]),i&amp;&amp;r.complete(),o=!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>))}</span>}</span>function <span class="fstat-no" title="function not covered" >pt(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return bt(!1,e,t,n)}</span>function <span class="fstat-no" title="function not covered" >mt(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return bt(!0,e,t,n)}</span>const{isArray:vt}=Array,{getPrototypeOf:wt,prototype:yt,keys:xt}=Object;function <span class="fstat-no" title="function not covered" >_t(</span>e){<span class="cstat-no" title="statement not covered" >if(1===e.length){const n=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>if(vt(n))<span class="cstat-no" title="statement not covered" >return{args:n,keys:null};<span class="cstat-no" title="statement not covered" >i</span></span>f((t=n)&amp;&amp;"object"==typeof t&amp;&amp;wt(t)===yt){const e=<span class="cstat-no" title="statement not covered" >xt(n);<span class="cstat-no" title="statement not covered" ></span>return{args:e.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >n[e])</span>),keys:e}}</span>}</span>v</span>ar t;<span class="cstat-no" title="statement not covered" >return{args:e,keys:null}}</span>function <span class="fstat-no" title="function not covered" >gt(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.reduce((<span class="fstat-no" title="function not covered" >(e</span>,n,r)=&gt;(<span class="cstat-no" title="statement not covered" >e[n]=t[r],e)</span>),{})}</span>function <span class="fstat-no" title="function not covered" >St(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Ee(e),</span>n=<span class="cstat-no" title="statement not covered" >Se(e),</span>{args:r,keys:s}=<span class="cstat-no" title="statement not covered" >_t(e);<span class="cstat-no" title="statement not covered" ></span>if(0===r.length)<span class="cstat-no" title="statement not covered" >return Ye([],t);c</span></span>onst o=<span class="cstat-no" title="statement not covered" >new j(Et(r,t,s?<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >gt(s,e):</span>A));<span class="cstat-no" title="statement not covered" ></span>return n?o.pipe(dt(n)):o}</span>function <span class="fstat-no" title="function not covered" >Et(</span>e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >A)</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >Ot(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const{length:s}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let i=<span class="cstat-no" title="statement not covered" >s,</span>c=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>for(let u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;s;u++)<span class="cstat-no" title="statement not covered" >Ot(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const s=<span class="cstat-no" title="statement not covered" >Ye(e[u],t);</span>let l=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>s.subscribe(F(r,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >o[u]=e,l||(l=!0,c--),c||r.next(n(o.slice()))}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >--i||r.complete()}</span>)))}</span>),r)}</span></span>),r)}</span>}</span>function <span class="fstat-no" title="function not covered" >Ot(</span>e,t,n){<span class="cstat-no" title="statement not covered" >e?We(n,e,t):t()}</span>function <span class="fstat-no" title="function not covered" >Tt(</span>e,t,n,r,s,o,i,c){const u=<span class="cstat-no" title="statement not covered" >[];</span>let l=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >!1;</span>const f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >!h||u.length||l||t.complete()}</span>,</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >l&lt;r?b(e):u.push(e),</span></span>b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >o&amp;&amp;t.next(e),l++;l</span>et c=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>De(n(e,a++)).subscribe(F(t,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >null==s||s(e),o?d(e):t.next(e)}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >c=!0}</span>),void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(c)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >for(l--;u.length&amp;&amp;l&lt;r;){const e=<span class="cstat-no" title="statement not covered" >u.shift();<span class="cstat-no" title="statement not covered" ></span>i?We(t,i,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >b(e))</span>):b(e)}<span class="cstat-no" title="statement not covered" ></span>f</span>()}</span>catch(e){<span class="cstat-no" title="statement not covered" >t.error(e)}</span>}</span></span>)))}</span>;<span class="cstat-no" title="statement not covered" ></span>return e.subscribe(F(t,d,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >h=!0,f()}</span>))),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >null==c||c()}</span>}</span>function <span class="fstat-no" title="function not covered" >At(</span>t,n,r=<span class="branch-0 cbranch-no" title="branch not covered" >1/0)</span>{<span class="cstat-no" title="statement not covered" >return e(n)?At((<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >ht((<span class="fstat-no" title="function not covered" >(t</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >n(e,t,r,s))</span>)(De(t(e,r))))</span>,r):("number"==typeof n&amp;&amp;(r=n),N((<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >Tt(e,n,t,r))</span>))}</span>function <span class="fstat-no" title="function not covered" >It(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >1/0)</span>{<span class="cstat-no" title="statement not covered" >return At(A,e)}</span>function <span class="fstat-no" title="function not covered" >kt(</span>){<span class="cstat-no" title="statement not covered" >return It(1)}</span>function <span class="fstat-no" title="function not covered" >jt(</span>...e){<span class="cstat-no" title="statement not covered" >return kt()(Ye(e,Ee(e)))}</span>function <span class="fstat-no" title="function not covered" >Ct(</span>e){<span class="cstat-no" title="statement not covered" >return new j((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >De(e()).subscribe(t)}</span>))}</span>const Pt={connector:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new V,</span>resetOnDisconnect:!0};function <span class="fstat-no" title="function not covered" >Nt(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >Pt)</span>{let n=<span class="cstat-no" title="statement not covered" >null;</span>const{connector:r,resetOnDisconnect:s=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>=<span class="cstat-no" title="statement not covered" >t;</span>let o=<span class="cstat-no" title="statement not covered" >r();</span>const i=<span class="cstat-no" title="statement not covered" >new j((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >o.subscribe(e))</span>);<span class="cstat-no" title="statement not covered" ></span>return i.connect=<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >n&amp;&amp;!n.closed||(n=Ct((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e)</span>).subscribe(o),s&amp;&amp;n.add((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o=r())</span>)),n)</span>,i}</span>function <span class="fstat-no" title="function not covered" >Ft(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Se(e),</span>{args:n,keys:r}=<span class="cstat-no" title="statement not covered" >_t(e),</span>s=<span class="cstat-no" title="statement not covered" >new j((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const{length:t}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return void e.complete();c</span></span>onst s=<span class="cstat-no" title="statement not covered" >new Array(t);</span>let o=<span class="cstat-no" title="statement not covered" >t,</span>i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>for(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;t;c++){let t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>De(n[c]).subscribe(F(e,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t||(t=!0,i--),s[c]=e}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o--)</span>,void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o&amp;&amp;t||(i||e.next(r?gt(r,s):s),e.complete())}</span>)))}</span>}</span>));<span class="cstat-no" title="statement not covered" ></span>return t?s.pipe(dt(t)):s}</span>const qt=["addListener","removeListener"],Lt=["addEventListener","removeEventListener"],Rt=["on","off"];function <span class="fstat-no" title="function not covered" >zt(</span>t,n,r,s){<span class="cstat-no" title="statement not covered" >if(e(r)&amp;&amp;(s=r,r=void 0),s)<span class="cstat-no" title="statement not covered" >return zt(t,n,r).pipe(dt(s));c</span></span>onst[o,i]=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e(t.addEventListener)&amp;&amp;e(t.removeEventListener)}</span>(t)?Lt.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >t[e](n,s,r))</span></span>):<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e(t.addListener)&amp;&amp;e(t.removeListener)}</span>(t)?qt.map(Ut(t,n)):<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e(t.on)&amp;&amp;e(t.off)}</span>(t)?Rt.map(Ut(t,n)):[];<span class="cstat-no" title="statement not covered" ></span>if(!o&amp;&amp;Ce(t))<span class="cstat-no" title="statement not covered" >return At((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >zt(e,n,r))</span>)(De(t));<span class="cstat-no" title="statement not covered" >i</span></span>f(!o)<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid event target");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new j((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;<span class="cstat-no" title="statement not covered" >e.next(1&lt;t.length?t:t[0]);<span class="cstat-no" title="statement not covered" ></span></span>return o(t),<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i(t)}</span></span>))}</span>function <span class="fstat-no" title="function not covered" >Ut(</span>e,t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >e[n](t,r)}</span></span></span>function <span class="fstat-no" title="function not covered" >Dt(</span>t,n,r){<span class="cstat-no" title="statement not covered" >return r?Dt(t,n).pipe(dt(r)):new j((<span class="fstat-no" title="function not covered" >r=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >r.next(1===e.length?e[0]:e),</span></span>o=<span class="cstat-no" title="statement not covered" >t(s);<span class="cstat-no" title="statement not covered" ></span>return e(n)?<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n(s,o):</span>void 0}</span>))}</span>function <span class="fstat-no" title="function not covered" >Ht(</span>e,t,n,r,s){let o,i;function*<span class="fstat-no" title="function not covered" >c(</span>){<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >i;</span>!t||t(e);e=n(e))<span class="cstat-no" title="statement not covered" >yield o(e)}<span class="cstat-no" title="statement not covered" ></span></span>return 1===arguments.length?({initialState:i,condition:t,iterate:n,resultSelector:o=<span class="branch-0 cbranch-no" title="branch not covered" >A,</span>scheduler:s}=e):(i=e,!r||_e(r)?(o=A,s=r):o=r),Ct(s?<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >$e(c(),s):</span>c)}</span>function <span class="fstat-no" title="function not covered" >Wt(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return Ct((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e()?t:n)</span>)}</span>function <span class="fstat-no" title="function not covered" >Mt(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>t,n=<span class="branch-0 cbranch-no" title="branch not covered" >fe)</span>{let r=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>return null!=t&amp;&amp;(_e(t)?n=t:r=t),new j((<span class="fstat-no" title="function not covered" >t=</span>&gt;{let s=<span class="cstat-no" title="statement not covered" >ct(e)?+e-n.now():e;<span class="cstat-no" title="statement not covered" ></span>s&lt;0&amp;&amp;(s=0);l</span>et o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return n.schedule((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.closed||(t.next(o++),0&lt;=r?this.schedule(void 0,r):t.complete())}</span>),s)}</span>))}</span>function <span class="fstat-no" title="function not covered" >Vt(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >he)</span>{<span class="cstat-no" title="statement not covered" >return e&lt;0&amp;&amp;(e=0),Mt(e,e,t)}</span>function <span class="fstat-no" title="function not covered" >$t(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Ee(e),</span>n=<span class="cstat-no" title="statement not covered" >Oe(e,1/0),</span>r=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return r.length?1===r.length?De(r[0]):It(n)(Ye(r,t)):ye}</span>const Bt=new j(h);function <span class="fstat-no" title="function not covered" >Xt(</span>){<span class="cstat-no" title="statement not covered" >return Bt}</span>const{isArray:Yt}=Array;function <span class="fstat-no" title="function not covered" >Jt(</span>e){<span class="cstat-no" title="statement not covered" >return 1===e.length&amp;&amp;Yt(e[0])?e[0]:e}</span>function <span class="fstat-no" title="function not covered" >Gt(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Jt(e);<span class="cstat-no" title="statement not covered" ></span>return new j((<span class="fstat-no" title="function not covered" >e=</span>&gt;{let n=<span class="cstat-no" title="statement not covered" >0;</span>const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(n&lt;t.length){let s;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >s=De(t[n++])}</span>catch(e){<span class="cstat-no" title="statement not covered" >return void r()}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >new q(e,void 0,h,h);<span class="cstat-no" title="statement not covered" ></span>s.subscribe(o),o.add(r)}</span>else <span class="cstat-no" title="statement not covered" >e.complete()}</span></span>;<span class="cstat-no" title="statement not covered" ></span>r()}</span>))}</span>function <span class="fstat-no" title="function not covered" >Zt(</span>e,t){<span class="cstat-no" title="statement not covered" >return Ye(Object.entries(e),t)}</span>function <span class="fstat-no" title="function not covered" >Kt(</span>e,t){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >!e.call(t,n,r)}</span></span>function <span class="fstat-no" title="function not covered" >Qt(</span>e,t){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>n.subscribe(F(r,(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >e.call(t,n,s++)&amp;&amp;r.next(n))</span>))}</span>))}</span>function <span class="fstat-no" title="function not covered" >en(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return[Qt(t,n)(De(e)),Qt(Kt(t,n))(De(e))]}</span>function <span class="fstat-no" title="function not covered" >tn(</span>...e){<span class="cstat-no" title="statement not covered" >return 1===(e=Jt(e)).length?De(e[0]):new j(nn(e))}</span>function <span class="fstat-no" title="function not covered" >nn(</span>e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=</span>&gt;{let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>n&amp;&amp;!t.closed&amp;&amp;r&lt;e.length;r++)<span class="cstat-no" title="statement not covered" >n.push(De(e[r]).subscribe(F(t,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;n.length;e++)<span class="cstat-no" title="statement not covered" >e!==r&amp;&amp;n[e].unsubscribe();<span class="cstat-no" title="statement not covered" >n</span></span>=null}<span class="cstat-no" title="statement not covered" ></span>t</span>.next(e)}</span>))))}</span></span>}</span>function <span class="fstat-no" title="function not covered" >rn(</span>e,t,n){<span class="cstat-no" title="statement not covered" >if(null==t&amp;&amp;(t=e,e=0),t&lt;=0)<span class="cstat-no" title="statement not covered" >return ye;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >t+e;<span class="cstat-no" title="statement not covered" ></span>return new j(n?<span class="fstat-no" title="function not covered" >t=</span>&gt;{let s=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return n.schedule((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >s&lt;r?(t.next(s++),this.schedule()):t.complete()}</span>))}</span>:<span class="fstat-no" title="function not covered" >t=</span>&gt;{let n=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;r&amp;&amp;!t.closed;)<span class="cstat-no" title="statement not covered" >t.next(n++);<span class="cstat-no" title="statement not covered" >t</span></span>.complete()}</span>)}</span>function <span class="fstat-no" title="function not covered" >sn(</span>e,t){<span class="cstat-no" title="statement not covered" >return new j((<span class="fstat-no" title="function not covered" >n=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >e(),</span>s=<span class="cstat-no" title="statement not covered" >t(r);<span class="cstat-no" title="statement not covered" ></span>return(s?De(s):ye).subscribe(n),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r&amp;&amp;r.unsubscribe()}</span>}</span>))}</span>function <span class="fstat-no" title="function not covered" >on(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Se(e),</span>n=<span class="cstat-no" title="statement not covered" >Jt(e);<span class="cstat-no" title="statement not covered" ></span>return n.length?new j((<span class="fstat-no" title="function not covered" >e=</span>&gt;{let r=<span class="cstat-no" title="statement not covered" >n.map((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[])</span>),</span>s=<span class="cstat-no" title="statement not covered" >n.map((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1)</span>);<span class="cstat-no" title="statement not covered" ></span>e.add((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r=s=null}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >0;</span>!e.closed&amp;&amp;o&lt;n.length;o++)<span class="cstat-no" title="statement not covered" >De(n[o]).subscribe(F(e,(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(r[o].push(n),r.every((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.length)</span>)){const n=<span class="cstat-no" title="statement not covered" >r.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.shift())</span>);<span class="cstat-no" title="statement not covered" ></span>e.next(t?t(...n):n),r.some((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >!e.length&amp;&amp;s[t])</span>)&amp;&amp;e.complete()}</span>}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s[o]=!0,!r[o].length&amp;&amp;e.complete()}</span>)));<span class="cstat-no" title="statement not covered" >r</span></span>eturn<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r=s=null}</span>}</span>)):ye}</span>function <span class="fstat-no" title="function not covered" >cn(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >!1,</span>s=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >null,</span>i=<span class="cstat-no" title="statement not covered" >!1;</span>const c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(null==o||o.unsubscribe(),o=null,r){<span class="cstat-no" title="statement not covered" >r=!1;c</span>onst e=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>s=null,n.next(e)}<span class="cstat-no" title="statement not covered" ></span>i</span>&amp;&amp;n.complete()}</span>,</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o=null,i&amp;&amp;n.complete()}</span>;<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >r=!0,s=t,o||De(e(t)).subscribe(o=F(n,c,u))}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i=!0,(!r||!o||o.closed)&amp;&amp;n.complete()}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >un(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >he)</span>{<span class="cstat-no" title="statement not covered" >return cn((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Mt(e,t))</span>)}</span>function <span class="fstat-no" title="function not covered" >ln(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >r.push(e))</span>,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n.next(r),n.complete()}</span>))),De(e).subscribe(F(n,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const e=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>r=[],n.next(e)}</span>),h)),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r=null}</span>}</span>))}</span>function <span class="fstat-no" title="function not covered" >an(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >return t=null!=t?t:e,N((<span class="fstat-no" title="function not covered" >(n</span>,s)=&gt;{let o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>n.subscribe(F(s,(<span class="fstat-no" title="function not covered" >n=</span>&gt;{let c=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>i++%t==0&amp;&amp;o.push([]);<span class="cstat-no" title="statement not covered" >f</span>or(const t of o)<span class="cstat-no" title="statement not covered" >t.push(n),e&lt;=t.length&amp;&amp;(c=null!=c?c:[],c.push(t));<span class="cstat-no" title="statement not covered" >i</span></span>f(c)<span class="cstat-no" title="statement not covered" >for(const e of c)<span class="cstat-no" title="statement not covered" >r(o,e),s.next(e)}</span></span></span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of o)<span class="cstat-no" title="statement not covered" >s.next(e);<span class="cstat-no" title="statement not covered" >s</span></span>.complete()}</span>),void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o=null}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >hn(</span>e,...t){var n,o;const i=<span class="cstat-no" title="statement not covered" >null!==(n=Ee(t))&amp;&amp;void 0!==n?n:he,</span>c=<span class="cstat-no" title="statement not covered" >null!==(o=t[0])&amp;&amp;void 0!==o?o:null,</span>u=<span class="cstat-no" title="statement not covered" >t[1]||1/0;<span class="cstat-no" title="statement not covered" ></span>return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let o=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" >!1;</span>const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{const{buffer:t,subs:s}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>s.unsubscribe(),r(o,e),n.next(t),l&amp;&amp;h()}</span>,</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(o){const t=<span class="cstat-no" title="statement not covered" >new s;<span class="cstat-no" title="statement not covered" ></span>n.add(t);c</span>onst r=<span class="cstat-no" title="statement not covered" >{buffer:[],subs:t};<span class="cstat-no" title="statement not covered" ></span>o.push(r),We(t,i,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >a(r))</span>,e)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>null!==c&amp;&amp;c&gt;=0?We(n,i,h,c,!0):l=!0,h();c</span>onst f=<span class="cstat-no" title="statement not covered" >F(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >o.slice();<span class="cstat-no" title="statement not covered" ></span>for(const n of t){const{buffer:t}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>t.push(e),u&lt;=t.length&amp;&amp;a(n)}</span>}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(;null==o?void 0:o.length;)<span class="cstat-no" title="statement not covered" >n.next(o.shift().buffer);<span class="cstat-no" title="statement not covered" >n</span></span>ull==f||f.unsubscribe(),n.complete(),n.unsubscribe()}</span>),void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o=null)</span>);<span class="cstat-no" title="statement not covered" ></span>t.subscribe(f)}</span>))}</span>function <span class="fstat-no" title="function not covered" >fn(</span>e,t){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,o)=&gt;{const i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>De(e).subscribe(F(o,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i.push(n);c</span>onst c=<span class="cstat-no" title="statement not covered" >new s;<span class="cstat-no" title="statement not covered" ></span>c.add(De(t(e)).subscribe(F(o,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r(i,n),o.next(n),c.unsubscribe()}</span>),h)))}</span>),h)),n.subscribe(F(o,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(const t of i)<span class="cstat-no" title="statement not covered" >t.push(e)}</span></span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(;i.length&gt;0;)<span class="cstat-no" title="statement not covered" >o.next(i.shift());<span class="cstat-no" title="statement not covered" >o</span></span>.complete()}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >dn(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >null,</span>s=<span class="cstat-no" title="statement not covered" >null;</span>const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >null==s||s.unsubscribe();c</span>onst t=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>r=[],t&amp;&amp;n.next(t),De(e()).subscribe(s=F(n,o,h))}</span>;<span class="cstat-no" title="statement not covered" ></span>o(),t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >null==r?void 0:r.push(e))</span>,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r&amp;&amp;n.next(r),n.complete()}</span>),void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r=s=null)</span>))}</span>))}</span>function bn(e){return N(((t,n)=&gt;{let r,s=null,o=!1;s=t.subscribe(F(n,void 0,void 0,(i=&gt;{r=De(e(i,bn(e)(t))),s?(s.unsubscribe(),s=null,r.subscribe(n)):o=!0}))),o&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >s.unsubscribe(),s=null,r.subscribe(n))</span>}))}function <span class="fstat-no" title="function not covered" >pn(</span>e,t,n,r,s){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(o</span>,i)=&gt;{let c=<span class="cstat-no" title="statement not covered" >n,</span>u=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>o.subscribe(F(i,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >l++;<span class="cstat-no" title="statement not covered" ></span>u=c?e(u,t,n):(c=!0,t),r&amp;&amp;i.next(u)}</span>),s&amp;&amp;(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >c&amp;&amp;i.next(u),i.complete()}</span>)))}</span>}</span>function <span class="fstat-no" title="function not covered" >mn(</span>e,t){<span class="cstat-no" title="statement not covered" >return N(pn(e,t,arguments.length&gt;=2,!1,!0))}</span>const vn=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;(<span class="cstat-no" title="statement not covered" >e.push(t),e)</span>;function <span class="fstat-no" title="function not covered" >wn(</span>){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >mn(vn,[])(e).subscribe(t)}</span>))}</span>function <span class="fstat-no" title="function not covered" >yn(</span>e,t){<span class="cstat-no" title="statement not covered" >return I(wn(),At((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e(t))</span>),t?dt(t):A)}</span>function <span class="fstat-no" title="function not covered" >xn(</span>e){<span class="cstat-no" title="statement not covered" >return yn(St,e)}</span>const _n=xn;function <span class="fstat-no" title="function not covered" >gn(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Se(e);<span class="cstat-no" title="statement not covered" ></span>return t?I(gn(...e),dt(t)):N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >Et([t,...Jt(e)])(n)}</span>))}</span>function <span class="fstat-no" title="function not covered" >Sn(</span>...e){<span class="cstat-no" title="statement not covered" >return gn(...e)}</span>function <span class="fstat-no" title="function not covered" >En(</span>t,n){<span class="cstat-no" title="statement not covered" >return e(n)?At(t,n,1):At(t,1)}</span>function <span class="fstat-no" title="function not covered" >On(</span>t,n){<span class="cstat-no" title="statement not covered" >return e(n)?En((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>,n):En((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>)}</span>function <span class="fstat-no" title="function not covered" >Tn(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Ee(e);<span class="cstat-no" title="statement not covered" ></span>return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >kt()(Ye([n,...e],t)).subscribe(r)}</span>))}</span>function <span class="fstat-no" title="function not covered" >An(</span>...e){<span class="cstat-no" title="statement not covered" >return Tn(...e)}</span>const In={connector:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new V}</span>;function <span class="fstat-no" title="function not covered" >kn(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >In)</span>{const{connector:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return N((<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{const s=<span class="cstat-no" title="statement not covered" >n();</span>var o;<span class="cstat-no" title="statement not covered" >De(e((o=s,new j((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >o.subscribe(e))</span>)))).subscribe(r),r.add(t.subscribe(s))}</span>))}</span>function <span class="fstat-no" title="function not covered" >jn(</span>e){<span class="cstat-no" title="statement not covered" >return mn((<span class="fstat-no" title="function not covered" >(t</span>,n,r)=&gt;<span class="cstat-no" title="statement not covered" >!e||e(n,r)?t+1:t)</span>,0)}</span>function <span class="fstat-no" title="function not covered" >Cn(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >!1,</span>s=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >null;</span>const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(null==o||o.unsubscribe(),o=null,r){<span class="cstat-no" title="statement not covered" >r=!1;c</span>onst e=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>s=null,n.next(e)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >null==o||o.unsubscribe(),r=!0,s=t,o=F(n,i,h),De(e(t)).subscribe(o)}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i(),n.complete()}</span>),void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s=o=null}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Pn(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >he)</span>{<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >null,</span>i=<span class="cstat-no" title="statement not covered" >null;</span>const c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(s){<span class="cstat-no" title="statement not covered" >s.unsubscribe(),s=null;c</span>onst e=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>o=null,r.next(e)}</span>}</span>;</span>function <span class="fstat-no" title="function not covered" >u(</span>){const n=<span class="cstat-no" title="statement not covered" >i+e,</span>o=<span class="cstat-no" title="statement not covered" >t.now();<span class="cstat-no" title="statement not covered" ></span>if(o&lt;n)<span class="cstat-no" title="statement not covered" >return s=this.schedule(void 0,n-o),void r.add(s);<span class="cstat-no" title="statement not covered" >c</span></span>()}<span class="cstat-no" title="statement not covered" ></span>n.subscribe(F(r,(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >o=n,i=t.now(),s||(s=t.schedule(u,e),r.add(s))}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >c(),r.complete()}</span>),void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o=s=null}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Nn(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r=!0,n.next(e)}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r||n.next(e),n.complete()}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Fn(</span>e){<span class="cstat-no" title="statement not covered" >return e&lt;=0?<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ye:</span>N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >++r&lt;=e&amp;&amp;(n.next(t),e&lt;=r&amp;&amp;n.complete())}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >qn(</span>){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >e.subscribe(F(t,h))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Ln(</span>e){<span class="cstat-no" title="statement not covered" >return ht((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e)</span>)}</span>function <span class="fstat-no" title="function not covered" >Rn(</span>e,t){<span class="cstat-no" title="statement not covered" >return t?<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >jt(t.pipe(Fn(1),qn()),n.pipe(Rn(e))):</span>At((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >De(e(t,n)).pipe(Fn(1),Ln(t)))</span>)}</span>function <span class="fstat-no" title="function not covered" >zn(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >he)</span>{const n=<span class="cstat-no" title="statement not covered" >Mt(e,t);<span class="cstat-no" title="statement not covered" ></span>return Rn((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n)</span>)}</span>function <span class="fstat-no" title="function not covered" >Un(</span>){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >e.subscribe(F(t,(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Qe(e,t))</span>))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Dn(</span>e,t){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{const s=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>n.subscribe(F(r,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >e?e(t):t;<span class="cstat-no" title="statement not covered" ></span>s.has(n)||(s.add(n),r.next(t))}</span>))),t&amp;&amp;De(t).subscribe(F(r,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s.clear())</span>,h))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Hn(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >A)</span>{<span class="cstat-no" title="statement not covered" >return e=null!=e?e:Wn,N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{let s,o=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>n.subscribe(F(r,(<span class="fstat-no" title="function not covered" >n=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >t(n);<span class="cstat-no" title="statement not covered" ></span>!o&amp;&amp;e(s,i)||(o=!1,s=i,r.next(n))}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Wn(</span>e,t){<span class="cstat-no" title="statement not covered" >return e===t}</span>function <span class="fstat-no" title="function not covered" >Mn(</span>e,t){<span class="cstat-no" title="statement not covered" >return Hn((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >t?t(n[e],r[e]):n[e]===r[e])</span>)}</span>function <span class="fstat-no" title="function not covered" >Vn(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >$n)</span>{<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r=!0,n.next(e)}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r?n.complete():n.error(e()))</span>))}</span>))}</span>function <span class="fstat-no" title="function not covered" >$n(</span>){<span class="cstat-no" title="statement not covered" >return new tt}</span>function <span class="fstat-no" title="function not covered" >Bn(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e&lt;0)<span class="cstat-no" title="statement not covered" >throw new st;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;=2;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.pipe(Qt((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >n===e)</span>),Fn(1),n?Nn(t):Vn((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new st)</span>))}</span></span>function <span class="fstat-no" title="function not covered" >Xn(</span>...e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >jt(t,Je(...e))}</span></span>function <span class="fstat-no" title="function not covered" >Yn(</span>e,t){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>n.subscribe(F(r,(<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.call(t,o,s++,n)||(r.next(!1),r.complete())}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.next(!0),r.complete()}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Jn(</span>e,t){<span class="cstat-no" title="statement not covered" >return t?<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.pipe(Jn((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >De(e(n,r)).pipe(ht((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t(n,e,r,s))</span>)))</span>)):</span>N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s||(s=F(n,void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s=null,o&amp;&amp;n.complete()}</span>)),De(e(t,r++)).subscribe(s))}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o=!0,!s&amp;&amp;n.complete()}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Gn(</span>){<span class="cstat-no" title="statement not covered" >return Jn(A)}</span>const Zn=Gn;function <span class="fstat-no" title="function not covered" >Kn(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >1/0,</span>n){<span class="cstat-no" title="statement not covered" >return t=(t||0)&lt;1?1/0:t,N((<span class="fstat-no" title="function not covered" >(r</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >Tt(r,s,e,t,void 0,!0,n))</span>)}</span>function <span class="fstat-no" title="function not covered" >Qn(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t.subscribe(n)}</span>finally{<span class="cstat-no" title="statement not covered" >n.add(e)}</span>}</span>))}</span>function <span class="fstat-no" title="function not covered" >er(</span>e,t){<span class="cstat-no" title="statement not covered" >return N(tr(e,t,"value"))}</span>function <span class="fstat-no" title="function not covered" >tr(</span>e,t,n){const r=<span class="cstat-no" title="statement not covered" >"index"===n;<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >(n</span>,s)=&gt;{let o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>n.subscribe(F(s,(<span class="fstat-no" title="function not covered" >i=</span>&gt;{const c=<span class="cstat-no" title="statement not covered" >o++;<span class="cstat-no" title="statement not covered" ></span>e.call(t,i,c,n)&amp;&amp;(s.next(r?c:i),s.complete())}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s.next(r?-1:void 0),s.complete()}</span>)))}</span>}</span>function <span class="fstat-no" title="function not covered" >nr(</span>e,t){<span class="cstat-no" title="statement not covered" >return N(tr(e,t,"index"))}</span>function <span class="fstat-no" title="function not covered" >rr(</span>e,t){const n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;=2;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.pipe(e?Qt((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >e(t,n,r))</span>):A,Fn(1),n?Nn(t):Vn((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new tt)</span>))}</span></span>function <span class="fstat-no" title="function not covered" >sr(</span>e,t,n,r){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(s</span>,o)=&gt;{let i;<span class="cstat-no" title="statement not covered" >t&amp;&amp;"function"!=typeof t?({duration:n,element:i,connector:r}=t):i=t;c</span>onst c=<span class="cstat-no" title="statement not covered" >new Map,</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >c.forEach(e),e(o)}</span>,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >u((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.error(e))</span>);</span></span>let a=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >!1;</span>const f=<span class="cstat-no" title="statement not covered" >new q(o,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >try{const s=<span class="cstat-no" title="statement not covered" >e(t);</span>let u=<span class="cstat-no" title="statement not covered" >c.get(s);<span class="cstat-no" title="statement not covered" ></span>if(!u){<span class="cstat-no" title="statement not covered" >c.set(s,u=r?r():new V);c</span>onst e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const n=<span class="cstat-no" title="statement not covered" >new j((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >a++;c</span>onst n=<span class="cstat-no" title="statement not covered" >t.subscribe(e);<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n.unsubscribe(),0==--a&amp;&amp;h&amp;&amp;f.unsubscribe()}</span>}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.key=e,n}</span>(s,u);<span class="cstat-no" title="statement not covered" ></span>if(o.next(e),n){const t=<span class="cstat-no" title="statement not covered" >F(u,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >u.complete(),null==t||t.unsubscribe()}</span>),void 0,void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >c.delete(s))</span>);<span class="cstat-no" title="statement not covered" ></span>f.add(De(n(e)).subscribe(t))}</span>}<span class="cstat-no" title="statement not covered" ></span>u</span>.next(i?i(t):t)}</span>catch(e){<span class="cstat-no" title="statement not covered" >l(e)}</span>}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >u((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.complete())</span>))</span>,l,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >c.clear())</span>,(<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >h=!0,0===a)</span>));<span class="cstat-no" title="statement not covered" ></span>s.subscribe(f)}</span>))}</span>function <span class="fstat-no" title="function not covered" >or(</span>){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >e.subscribe(F(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.next(!1),t.complete()}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.next(!0),t.complete()}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >ir(</span>e){<span class="cstat-no" title="statement not covered" >return e&lt;=0?<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ye:</span>N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.push(t),e&lt;r.length&amp;&amp;r.shift()}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of r)<span class="cstat-no" title="statement not covered" >n.next(e);<span class="cstat-no" title="statement not covered" >n</span></span>.complete()}</span>),void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r=null}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >cr(</span>e,t){const n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;=2;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.pipe(e?Qt((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >e(t,n,r))</span>):A,ir(1),n?Nn(t):Vn((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new tt)</span>))}</span></span>function <span class="fstat-no" title="function not covered" >ur(</span>){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >e.subscribe(F(t,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.next(Ke.createNext(e))}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.next(Ke.createComplete()),t.complete()}</span>),(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.next(Ke.createError(e)),t.complete()}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >lr(</span>t){<span class="cstat-no" title="statement not covered" >return mn(e(t)?<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >t(e,n)&gt;0?e:n:<span class="fstat-no" title="function not covered" ></span>(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e&gt;t?e:t)</span>}</span>const ar=At;function <span class="fstat-no" title="function not covered" >hr(</span>t,n,r=<span class="branch-0 cbranch-no" title="branch not covered" >1/0)</span>{<span class="cstat-no" title="statement not covered" >return e(n)?At((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>,n,r):("number"==typeof n&amp;&amp;(r=n),At((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>,r))}</span>function <span class="fstat-no" title="function not covered" >fr(</span>e,t,n=<span class="branch-0 cbranch-no" title="branch not covered" >1/0)</span>{<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(r</span>,s)=&gt;{let o=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return Tt(r,s,(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >e(o,t,n))</span>,n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >o=e}</span>),!1,void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o=null)</span>)}</span>))}</span>function <span class="fstat-no" title="function not covered" >dr(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Ee(e),</span>n=<span class="cstat-no" title="statement not covered" >Oe(e,1/0);<span class="cstat-no" title="statement not covered" ></span>return e=Jt(e),N((<span class="fstat-no" title="function not covered" >(r</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >It(n)(Ye([r,...e],t)).subscribe(s)}</span>))}</span>function <span class="fstat-no" title="function not covered" >br(</span>...e){<span class="cstat-no" title="statement not covered" >return dr(...e)}</span>function <span class="fstat-no" title="function not covered" >pr(</span>t){<span class="cstat-no" title="statement not covered" >return mn(e(t)?<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >t(e,n)&lt;0?e:n:<span class="fstat-no" title="function not covered" ></span>(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;t?e:t)</span>}</span>function <span class="fstat-no" title="function not covered" >mr(</span>t,n){const r=<span class="cstat-no" title="statement not covered" >e(t)?t:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span></span>return e(n)?kn(n,{connector:r}):<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new R(e,r)}</span></span>function <span class="fstat-no" title="function not covered" >vr(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Jt(e);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Gt(e,...t)}</span></span>const wr=vr;function <span class="fstat-no" title="function not covered" >yr(</span>){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let n,r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>e.subscribe(F(t,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>n=e,r&amp;&amp;t.next([s,e]),r=!0}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >xr(</span>...e){const t=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>if(0===t)<span class="cstat-no" title="statement not covered" >throw new Error("list of properties cannot be empty.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn ht((<span class="fstat-no" title="function not covered" >n=</span>&gt;{let r=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t;n++){const t=<span class="cstat-no" title="statement not covered" >null==r?void 0:r[e[n]];<span class="cstat-no" title="statement not covered" ></span>if(void 0===t)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span>=t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>))}</span>function <span class="fstat-no" title="function not covered" >_r(</span>e){<span class="cstat-no" title="statement not covered" >return e?<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >kn(e)(t):<span class="fstat-no" title="function not covered" ></span>e=</span>&gt;<span class="cstat-no" title="statement not covered" >mr(new V)(e)}</span></span>function <span class="fstat-no" title="function not covered" >gr(</span>e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >new B(e);<span class="cstat-no" title="statement not covered" ></span>return new R(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n)</span>)}</span>}</span>function <span class="fstat-no" title="function not covered" >Sr(</span>){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >new J;<span class="cstat-no" title="statement not covered" ></span>return new R(e,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>)}</span>}</span>function <span class="fstat-no" title="function not covered" >Er(</span>t,n,r,s){<span class="cstat-no" title="statement not covered" >r&amp;&amp;!e(r)&amp;&amp;(s=r);c</span>onst o=<span class="cstat-no" title="statement not covered" >e(r)?r:void 0;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >mr(new Y(t,n,s),o)(e)}</span></span>function <span class="fstat-no" title="function not covered" >Or(</span>...e){<span class="cstat-no" title="statement not covered" >return e.length?N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >nn([t,...e])(n)}</span>)):A}</span>function <span class="fstat-no" title="function not covered" >Tr(</span>e){let t,n=<span class="cstat-no" title="statement not covered" >1/0;<span class="cstat-no" title="statement not covered" ></span>return null!=e&amp;&amp;("object"==typeof e?({count:n=<span class="branch-0 cbranch-no" title="branch not covered" >1/0,</span>delay:t}=e):n=e),n&lt;=0?<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ye:</span>N((<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{let s,o=<span class="cstat-no" title="statement not covered" >0;</span>const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(null==s||s.unsubscribe(),s=null,null!=t){const e=<span class="cstat-no" title="statement not covered" >"number"==typeof t?Mt(t):De(t(o)),</span>n=<span class="cstat-no" title="statement not covered" >F(r,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n.unsubscribe(),c()}</span>));<span class="cstat-no" title="statement not covered" ></span>e.subscribe(n)}</span>else <span class="cstat-no" title="statement not covered" >c()}</span></span>,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{let t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>s=e.subscribe(F(r,void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >++o&lt;n?s?i():t=!0:r.complete()}</span>))),t&amp;&amp;i()}</span>;<span class="cstat-no" title="statement not covered" ></span>c()}</span>))}</span>function <span class="fstat-no" title="function not covered" >Ar(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r,s,o=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >!1,</span>c=<span class="cstat-no" title="statement not covered" >!1;</span>const u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >c&amp;&amp;i&amp;&amp;(n.complete(),!0),</span></span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >c=!1,r=t.subscribe(F(n,void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >c=!0,!u()&amp;&amp;(s||(s=new V,De(e(s)).subscribe(F(n,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r?l():o=!0}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i=!0,u()}</span>)))),s).next()}</span>))),o&amp;&amp;(r.unsubscribe(),r=null,o=!1,l())}</span>;<span class="cstat-no" title="statement not covered" ></span>l()}</span>))}</span>function <span class="fstat-no" title="function not covered" >Ir(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >1/0)</span>{let t;<span class="cstat-no" title="statement not covered" >t=e&amp;&amp;"object"==typeof e?e:{count:e};c</span>onst{count:n=<span class="branch-0 cbranch-no" title="branch not covered" >1/0,</span>delay:r,resetOnSuccess:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return n&lt;=0?A:N((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let o,i=<span class="cstat-no" title="statement not covered" >0;</span>const c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{let u=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>o=e.subscribe(F(t,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >s&amp;&amp;(i=0),t.next(e)}</span>),void 0,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(i++&lt;n){const n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o?(o.unsubscribe(),o=null,c()):u=!0}</span>;<span class="cstat-no" title="statement not covered" ></span>if(null!=r){const s=<span class="cstat-no" title="statement not covered" >"number"==typeof r?Mt(r):De(r(e,i)),</span>o=<span class="cstat-no" title="statement not covered" >F(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o.unsubscribe(),n()}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.complete()}</span>));<span class="cstat-no" title="statement not covered" ></span>s.subscribe(o)}</span>else <span class="cstat-no" title="statement not covered" >n()}</span></span>else <span class="cstat-no" title="statement not covered" >t.error(e)}</span></span>))),u&amp;&amp;(o.unsubscribe(),o=null,c())}</span>;<span class="cstat-no" title="statement not covered" ></span>c()}</span>))}</span>function <span class="fstat-no" title="function not covered" >kr(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r,s,o=<span class="cstat-no" title="statement not covered" >!1;</span>const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r=t.subscribe(F(n,void 0,void 0,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s||(s=new V,De(e(s)).subscribe(F(n,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r?i():o=!0)</span>))),s&amp;&amp;s.next(t)}</span>))),o&amp;&amp;(r.unsubscribe(),r=null,o=!1,i())}</span>;<span class="cstat-no" title="statement not covered" ></span>i()}</span>))}</span>function <span class="fstat-no" title="function not covered" >jr(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >!1,</span>s=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r=!0,s=e}</span>))),De(e).subscribe(F(n,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(r){<span class="cstat-no" title="statement not covered" >r=!1;c</span>onst e=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>s=null,n.next(e)}</span>}</span>),h))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Cr(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >he)</span>{<span class="cstat-no" title="statement not covered" >return jr(Vt(e,t))}</span>function <span class="fstat-no" title="function not covered" >Pr(</span>e,t){<span class="cstat-no" title="statement not covered" >return N(pn(e,t,arguments.length&gt;=2,!0))}</span>function <span class="fstat-no" title="function not covered" >Nr(</span>e,t=(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e===t)</span></span>){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{const s=<span class="cstat-no" title="statement not covered" >{buffer:[],complete:!1},</span>o=<span class="cstat-no" title="statement not covered" >{buffer:[],complete:!1},</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.next(e),r.complete()}</span>,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{const s=<span class="cstat-no" title="statement not covered" >F(r,(<span class="fstat-no" title="function not covered" >r=</span>&gt;{const{buffer:s,complete:o}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>0===s.length?o?i(!1):e.buffer.push(r):!t(r,s.shift())&amp;&amp;i(!1)}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e.complete=!0;c</span>onst{complete:t,buffer:r}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;i(0===r.length),null==s||s.unsubscribe()}</span>));<span class="cstat-no" title="statement not covered" ></span>return s}</span>;<span class="cstat-no" title="statement not covered" ></span>n.subscribe(c(s,o)),De(e).subscribe(c(o,s))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Fr(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const{connector:t=(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new V)</span></span>,resetOnError:n=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>resetOnComplete:r=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>resetOnRefCountZero:s=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >e=</span>&gt;{let o,i,c,u=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >!1,</span>a=<span class="cstat-no" title="statement not covered" >!1;</span>const h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >null==i||i.unsubscribe(),i=void 0}</span>,</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >h(),o=c=void 0,l=a=!1}</span>,</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{const e=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>f(),null==e||e.unsubscribe()}</span>;<span class="cstat-no" title="statement not covered" ></span>return N((<span class="fstat-no" title="function not covered" >(e</span>,b)=&gt;{<span class="cstat-no" title="statement not covered" >u++,a||l||h();c</span>onst p=<span class="cstat-no" title="statement not covered" >c=null!=c?c:t();<span class="cstat-no" title="statement not covered" ></span>b.add((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >u--,0!==u||a||l||(i=qr(d,s))}</span>)),p.subscribe(b),!o&amp;&amp;u&gt;0&amp;&amp;(o=new g({next:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >p.next(e),</span>error:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >a=!0,h(),i=qr(f,n,e),p.error(e)}</span>,complete:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >l=!0,h(),i=qr(f,r),p.complete()}</span>}),De(e).subscribe(o))}</span>))(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >qr(</span>e,t,...n){<span class="cstat-no" title="statement not covered" >if(!0===t)<span class="cstat-no" title="statement not covered" >return void e();<span class="cstat-no" title="statement not covered" >i</span></span>f(!1===t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >new g({next:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.unsubscribe(),e()}</span>});<span class="cstat-no" title="statement not covered" ></span>return De(t(...n)).subscribe(r)}</span>function <span class="fstat-no" title="function not covered" >Lr(</span>e,t,n){let r,s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;"object"==typeof e?({bufferSize:r=<span class="branch-0 cbranch-no" title="branch not covered" >1/0,</span>windowTime:t=<span class="branch-0 cbranch-no" title="branch not covered" >1/0,</span>refCount:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>scheduler:n}=e):r=null!=e?e:1/0,Fr({connector:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new Y(r,t,n),</span>resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:s})}</span>function <span class="fstat-no" title="function not covered" >Rr(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r,s=<span class="cstat-no" title="statement not covered" >!1,</span>o=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >c=</span>&gt;{<span class="cstat-no" title="statement not covered" >o=!0,e&amp;&amp;!e(c,i++,t)||(s&amp;&amp;n.error(new it("Too many matching values")),s=!0,r=c)}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s?(n.next(r),n.complete()):n.error(o?new ot("No matching values"):new tt)}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >zr(</span>e){<span class="cstat-no" title="statement not covered" >return Qt((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;=n)</span>)}</span>function <span class="fstat-no" title="function not covered" >Ur(</span>e){<span class="cstat-no" title="statement not covered" >return e&lt;=0?A:N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >new Array(e),</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const o=<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" ></span>if(o&lt;e)<span class="cstat-no" title="statement not covered" >r[o]=t;e</span>lse{const s=<span class="cstat-no" title="statement not covered" >o%e,</span>i=<span class="cstat-no" title="statement not covered" >r[s];<span class="cstat-no" title="statement not covered" ></span>r[s]=t,n.next(i)}</span>}</span>))),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r=null}</span>}</span>))}</span>function <span class="fstat-no" title="function not covered" >Dr(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >!1;</span>const s=<span class="cstat-no" title="statement not covered" >F(n,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >null==s||s.unsubscribe(),r=!0}</span>),h);<span class="cstat-no" title="statement not covered" ></span>De(e).subscribe(s),t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >r&amp;&amp;n.next(e))</span>))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Hr(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >!1,</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(r||(r=!e(t,s++)))&amp;&amp;n.next(t))</span>))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Wr(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Ee(e);<span class="cstat-no" title="statement not covered" ></span>return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >(t?jt(e,n,t):jt(e,n)).subscribe(r)}</span>))}</span>function <span class="fstat-no" title="function not covered" >Mr(</span>e,t){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >!1;</span>const c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i&amp;&amp;!s&amp;&amp;r.complete();<span class="cstat-no" title="statement not covered" ></span></span>n.subscribe(F(r,(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >null==s||s.unsubscribe();l</span>et i=<span class="cstat-no" title="statement not covered" >0;</span>const u=<span class="cstat-no" title="statement not covered" >o++;<span class="cstat-no" title="statement not covered" ></span>De(e(n,u)).subscribe(s=F(r,(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >r.next(t?t(n,e,u,i++):e))</span>,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s=null,c()}</span>)))}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i=!0,c()}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Vr(</span>){<span class="cstat-no" title="statement not covered" >return Mr(A)}</span>function <span class="fstat-no" title="function not covered" >$r(</span>t,n){<span class="cstat-no" title="statement not covered" >return e(n)?Mr((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>,n):Mr((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t)</span>)}</span>function <span class="fstat-no" title="function not covered" >Br(</span>e,t){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return Mr((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >e(s,t,n))</span>,(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;(<span class="cstat-no" title="statement not covered" >s=t,t)</span>))(n).subscribe(r),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s=null}</span>}</span>))}</span>function <span class="fstat-no" title="function not covered" >Xr(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >De(e).subscribe(F(n,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n.complete())</span>,h)),!n.closed&amp;&amp;t.subscribe(n)}</span>))}</span>function <span class="fstat-no" title="function not covered" >Yr(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>n.subscribe(F(r,(<span class="fstat-no" title="function not covered" >n=</span>&gt;{const o=<span class="cstat-no" title="statement not covered" >e(n,s++);<span class="cstat-no" title="statement not covered" ></span>(o||t)&amp;&amp;r.next(n),!o&amp;&amp;r.complete()}</span>)))}</span>))}</span>function Jr(t,n,r){const s=e(t)||<span class="branch-1 cbranch-no" title="branch not covered" >n|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >r?</span>{next:t,error:n,complete:r}:<span class="branch-1 cbranch-no" title="branch not covered" >t;</span>return s?N(((e,t)=&gt;{var n;null===(n=s.subscribe)||void 0===n||<span class="branch-2 cbranch-no" title="branch not covered" >n.call(s);</span>let r=!0;e.subscribe(F(t,(e=&gt;{var n;null===(n=s.next)||void 0===n||n.call(s,e),t.next(e)}),(()=&gt;{var e;r=!1,null===(e=s.complete)||void 0===e||<span class="branch-2 cbranch-no" title="branch not covered" >e.call(s),</span>t.complete()}),(e=&gt;{var n;r=!1,null===(n=s.error)||void 0===n||<span class="branch-2 cbranch-no" title="branch not covered" >n.call(s,e),</span>t.error(e)}),(()=&gt;{var e,t;r&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >null===(e=s.unsubscribe)|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >void 0===e|</span>|<span class="branch-3 cbranch-no" title="branch not covered" >e.call(s))</span>,null===(t=s.finalize)||void 0===t||<span class="branch-2 cbranch-no" title="branch not covered" >t.call(s)}</span>)))})):<span class="branch-1 cbranch-no" title="branch not covered" >A}</span>function <span class="fstat-no" title="function not covered" >Gr(</span>e,t){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{const{leading:s=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>trailing:o=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="cstat-no" title="statement not covered" >null!=t?t:{};</span>let i=<span class="cstat-no" title="statement not covered" >!1,</span>c=<span class="cstat-no" title="statement not covered" >null,</span>u=<span class="cstat-no" title="statement not covered" >null,</span>l=<span class="cstat-no" title="statement not covered" >!1;</span>const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >null==u||u.unsubscribe(),u=null,o&amp;&amp;(d(),l&amp;&amp;r.complete())}</span>,</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >u=null,l&amp;&amp;r.complete()}</span>,</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >u=De(e(t)).subscribe(F(r,a,h)),</span></span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(i){<span class="cstat-no" title="statement not covered" >i=!1;c</span>onst e=<span class="cstat-no" title="statement not covered" >c;<span class="cstat-no" title="statement not covered" ></span>c=null,r.next(e),!l&amp;&amp;f(e)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>n.subscribe(F(r,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >i=!0,c=e,(!u||u.closed)&amp;&amp;(s?d():f(e))}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >l=!0,(!(o&amp;&amp;i&amp;&amp;u)||u.closed)&amp;&amp;r.complete()}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >Zr(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >he,</span>n){const r=<span class="cstat-no" title="statement not covered" >Mt(e,t);<span class="cstat-no" title="statement not covered" ></span>return Gr((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r)</span>,n)}</span>function <span class="fstat-no" title="function not covered" >Kr(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >he)</span>{<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >e.now();<span class="cstat-no" title="statement not covered" ></span>t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >e.now(),</span>o=<span class="cstat-no" title="statement not covered" >s-r;<span class="cstat-no" title="statement not covered" ></span>r=s,n.next(new Qr(t,o))}</span>)))}</span>))}</span>class Qr{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >this.value=e,this.interval=t}</span>}function <span class="fstat-no" title="function not covered" >es(</span>e,t,n){let r,s,o;<span class="cstat-no" title="statement not covered" >if(n=null!=n?n:fe,ct(e)?r=e:"number"==typeof e&amp;&amp;(s=e),!t)<span class="cstat-no" title="statement not covered" >throw new TypeError("No observable provided to switch to");<span class="cstat-no" title="statement not covered" >i</span></span>f(o=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t,</span>null==r&amp;&amp;null==s)<span class="cstat-no" title="statement not covered" >throw new TypeError("No timeout provided.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn lt({first:r,each:s,scheduler:n,with:o})}</span>function <span class="fstat-no" title="function not covered" >ts(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >X)</span>{<span class="cstat-no" title="statement not covered" >return ht((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{value:t,timestamp:e.now()})</span>))}</span>function <span class="fstat-no" title="function not covered" >ns(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r=<span class="cstat-no" title="statement not covered" >new V;<span class="cstat-no" title="statement not covered" ></span>n.next(r.asObservable());c</span>onst s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.error(e),n.error(e)}</span>;<span class="cstat-no" title="statement not covered" ></span>return t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >null==r?void 0:r.next(e))</span>,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.complete(),n.complete()}</span>),s)),De(e).subscribe(F(n,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.complete(),n.next(r=new V)}</span>),h,s)),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >null==r||r.unsubscribe(),r=null}</span>}</span>))}</span>function <span class="fstat-no" title="function not covered" >rs(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{const n=<span class="cstat-no" title="statement not covered" >t&gt;0?t:e;<span class="cstat-no" title="statement not covered" ></span>return N((<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >[new V],</span>o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>r.next(s[0].asObservable()),t.subscribe(F(r,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(const e of s)<span class="cstat-no" title="statement not covered" >e.next(t);c</span></span>onst o=<span class="cstat-no" title="statement not covered" >i-e+1;<span class="cstat-no" title="statement not covered" ></span>if(o&gt;=0&amp;&amp;o%n==0&amp;&amp;s.shift().complete(),++i%n==0){const e=<span class="cstat-no" title="statement not covered" >new V;<span class="cstat-no" title="statement not covered" ></span>s.push(e),r.next(e.asObservable())}</span>}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(;s.length&gt;0;)<span class="cstat-no" title="statement not covered" >s.shift().complete();<span class="cstat-no" title="statement not covered" >r</span></span>.complete()}</span>),(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(;s.length&gt;0;)<span class="cstat-no" title="statement not covered" >s.shift().error(e);<span class="cstat-no" title="statement not covered" >r</span></span>.error(e)}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o=null,s=null}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >ss(</span>e,...t){var n,o;const i=<span class="cstat-no" title="statement not covered" >null!==(n=Ee(t))&amp;&amp;void 0!==n?n:he,</span>c=<span class="cstat-no" title="statement not covered" >null!==(o=t[0])&amp;&amp;void 0!==o?o:null,</span>u=<span class="cstat-no" title="statement not covered" >t[1]||1/0;<span class="cstat-no" title="statement not covered" ></span>return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let o=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" >!1;</span>const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{const{window:t,subs:n}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>t.complete(),n.unsubscribe(),r(o,e),l&amp;&amp;h()}</span>,</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(o){const t=<span class="cstat-no" title="statement not covered" >new s;<span class="cstat-no" title="statement not covered" ></span>n.add(t);c</span>onst r=<span class="cstat-no" title="statement not covered" >new V,</span>c=<span class="cstat-no" title="statement not covered" >{window:r,subs:t,seen:0};<span class="cstat-no" title="statement not covered" ></span>o.push(c),n.next(r.asObservable()),We(t,i,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >a(c))</span>,e)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>null!==c&amp;&amp;c&gt;=0?We(n,i,h,c,!0):l=!0,h();c</span>onst f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >o.slice().forEach(e),</span></span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >f((<span class="fstat-no" title="function not covered" >({</span>window:t})=&gt;<span class="cstat-no" title="statement not covered" >e(t))</span>),e(n),n.unsubscribe()}</span>;<span class="cstat-no" title="statement not covered" ></span>return t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >f((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.window.next(e),u&lt;=++t.seen&amp;&amp;a(t)}</span>))}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >d((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.complete())</span>))</span>,(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >d((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.error(e))</span>))</span>)),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o=null}</span>}</span>))}</span>function <span class="fstat-no" title="function not covered" >os(</span>e,t){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(n</span>,o)=&gt;{const i=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(;0&lt;i.length;)<span class="cstat-no" title="statement not covered" >i.shift().error(e);<span class="cstat-no" title="statement not covered" >o</span></span>.error(e)}</span>;<span class="cstat-no" title="statement not covered" ></span>De(e).subscribe(F(o,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >new V;<span class="cstat-no" title="statement not covered" ></span>i.push(n);c</span>onst u=<span class="cstat-no" title="statement not covered" >new s;</span>let l;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >l=De(t(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >return void c(e)}<span class="cstat-no" title="statement not covered" ></span>o</span>.next(n.asObservable()),u.add(l.subscribe(F(o,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r(i,n),n.complete(),u.unsubscribe()}</span>),h,c)))}</span>),h)),n.subscribe(F(o,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.slice();<span class="cstat-no" title="statement not covered" ></span>for(const n of t)<span class="cstat-no" title="statement not covered" >n.next(e)}</span></span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(;0&lt;i.length;)<span class="cstat-no" title="statement not covered" >i.shift().complete();<span class="cstat-no" title="statement not covered" >o</span></span>.complete()}</span>),c,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(;0&lt;i.length;)<span class="cstat-no" title="statement not covered" >i.shift().unsubscribe()}</span></span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >is(</span>e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{let r,s;const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.error(e),n.error(e)}</span>,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{let t;<span class="cstat-no" title="statement not covered" >null==s||s.unsubscribe(),null==r||r.complete(),r=new V,n.next(r.asObservable());<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >t=De(e())}</span>catch(e){<span class="cstat-no" title="statement not covered" >return void o(e)}<span class="cstat-no" title="statement not covered" ></span>t</span>.subscribe(s=F(n,i,i,o))}</span>;<span class="cstat-no" title="statement not covered" ></span>i(),t.subscribe(F(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >r.next(e))</span>,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.complete(),n.complete()}</span>),o,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >null==s||s.unsubscribe(),r=null}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >cs(</span>...e){const t=<span class="cstat-no" title="statement not covered" >Se(e);<span class="cstat-no" title="statement not covered" ></span>return N((<span class="fstat-no" title="function not covered" >(n</span>,r)=&gt;{const s=<span class="cstat-no" title="statement not covered" >e.length,</span>o=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let i=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1)</span>),</span>c=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;s;t++)<span class="cstat-no" title="statement not covered" >De(e[t]).subscribe(F(r,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >o[t]=e,c||i[t]||(i[t]=!0,(c=i.every(A))&amp;&amp;(i=null))}</span>),h));<span class="cstat-no" title="statement not covered" >n</span></span>.subscribe(F(r,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(c){const n=<span class="cstat-no" title="statement not covered" >[e,...o];<span class="cstat-no" title="statement not covered" ></span>r.next(t?t(...n):n)}</span>}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >us(</span>e){<span class="cstat-no" title="statement not covered" >return yn(on,e)}</span>function <span class="fstat-no" title="function not covered" >ls(</span>...e){<span class="cstat-no" title="statement not covered" >return N((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >on(t,...e).subscribe(n)}</span>))}</span>function <span class="fstat-no" title="function not covered" >as(</span>...e){<span class="cstat-no" title="statement not covered" >return ls(...e)}</span>function <span class="fstat-no" title="function not covered" >hs(</span>e,t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >[Qt(e,t)(n),Qt(Kt(e,t))(n)]}</span></span>function <span class="fstat-no" title="function not covered" >fs(</span>...e){<span class="cstat-no" title="statement not covered" >return Or(...Jt(e))}</span>function <span class="fstat-no" title="function not covered" >ds(</span>e){<span class="cstat-no" title="statement not covered" >switch(e.responseType){case"json":<span class="cstat-no" title="statement not covered" >if("response"in e)<span class="cstat-no" title="statement not covered" >return e.response;{</span></span>const t=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return JSON.parse(t.responseText)}</span>case"document":<span class="cstat-no" title="statement not covered" >return e.responseXML;c</span>ase"text":default:<span class="cstat-no" title="statement not covered" >if("response"in e)<span class="cstat-no" title="statement not covered" >return e.response;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.responseText}</span>}</span>class bs{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,n,r=<span class="branch-0 cbranch-no" title="branch not covered" >"download_load")</span>{<span class="cstat-no" title="statement not covered" >this.originalEvent=e,this.xhr=t,this.request=n,this.type=r;c</span>onst{status:s,responseType:o}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>this.status=null!=s?s:0,this.responseType=null!=o?o:"";c</span>onst i=<span class="cstat-no" title="statement not covered" >t.getAllResponseHeaders();<span class="cstat-no" title="statement not covered" ></span>this.responseHeaders=i?i.split("\n").reduce((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const n=<span class="cstat-no" title="statement not covered" >t.indexOf(": ");<span class="cstat-no" title="statement not covered" ></span>return e[t.slice(0,n)]=t.slice(n+2),e}</span>),{}):{},this.response=ds(t);c</span>onst{loaded:c,total:u}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>this.loaded=c,this.total=u}</span>}const ps=t((e=&gt;<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){let r;<span class="cstat-no" title="statement not covered" >this.message=e,this.name="AjaxError",this.xhr=t,this.request=n,this.status=t.status,this.responseType=t.responseType;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >r=ds(t)}</span>catch(e){<span class="cstat-no" title="statement not covered" >r=t.responseText}<span class="cstat-no" title="statement not covered" ></span>t</span>his.response=r}</span>)),ms=(()=&gt;{function <span class="fstat-no" title="function not covered" >e(</span>e,t){<span class="cstat-no" title="statement not covered" >return ps.call(this,"ajax timeout",e,t),this.name="AjaxTimeoutError",this}</span>return e.prototype=Object.create(ps.prototype),e})();function <span class="fstat-no" title="function not covered" >vs(</span>e,t){<span class="cstat-no" title="statement not covered" >return Es({method:"GET",url:e,headers:t})}</span>function <span class="fstat-no" title="function not covered" >ws(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return Es({method:"POST",url:e,body:t,headers:n})}</span>function <span class="fstat-no" title="function not covered" >ys(</span>e,t){<span class="cstat-no" title="statement not covered" >return Es({method:"DELETE",url:e,headers:t})}</span>function <span class="fstat-no" title="function not covered" >xs(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return Es({method:"PUT",url:e,body:t,headers:n})}</span>function <span class="fstat-no" title="function not covered" >_s(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return Es({method:"PATCH",url:e,body:t,headers:n})}</span>const gs=ht((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.response)</span>);function <span class="fstat-no" title="function not covered" >Ss(</span>e,t){<span class="cstat-no" title="statement not covered" >return gs(Es({method:"GET",url:e,headers:t}))}</span>const Es=(()=&gt;{const e=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >return t="string"==typeof e?{url:e}:e,new j((<span class="fstat-no" title="function not covered" >e=</span>&gt;{var n,r;const s=<span class="cstat-no" title="statement not covered" >Object.assign({async:!0,crossDomain:!1,withCredentials:!1,method:"GET",timeout:0,responseType:"json"},t),</span>{queryParams:o,body:i,headers:c}=<span class="cstat-no" title="statement not covered" >s;</span>let u=<span class="cstat-no" title="statement not covered" >s.url;<span class="cstat-no" title="statement not covered" ></span>if(!u)<span class="cstat-no" title="statement not covered" >throw new TypeError("url is required");<span class="cstat-no" title="statement not covered" >i</span></span>f(o){let e;<span class="cstat-no" title="statement not covered" >if(u.includes("?")){const t=<span class="cstat-no" title="statement not covered" >u.split("?");<span class="cstat-no" title="statement not covered" ></span>if(2&lt;t.length)<span class="cstat-no" title="statement not covered" >throw new TypeError("invalid url");<span class="cstat-no" title="statement not covered" >e</span></span>=new URLSearchParams(t[1]),new URLSearchParams(o).forEach((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >e.set(n,t))</span>),u=t[0]+"?"+e}</span>else <span class="cstat-no" title="statement not covered" >e=new URLSearchParams(o),u=u+"?"+e}</span></span>c</span>onst l=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(c)<span class="cstat-no" title="statement not covered" >for(const e in c)<span class="cstat-no" title="statement not covered" >c.hasOwnProperty(e)&amp;&amp;(l[e.toLowerCase()]=c[e]);c</span></span></span>onst a=<span class="cstat-no" title="statement not covered" >s.crossDomain;<span class="cstat-no" title="statement not covered" ></span>a||"x-requested-with"in l||(l["x-requested-with"]="XMLHttpRequest");c</span>onst{withCredentials:h,xsrfCookieName:f,xsrfHeaderName:d}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if((h||!a)&amp;&amp;f&amp;&amp;d){const e=<span class="cstat-no" title="statement not covered" >null!==(r=null===(n=null===document||void 0===document?void 0:document.cookie.match(new RegExp(`(^|;\\s*)(${f})=([^;]*)`)))||void 0===n?void 0:n.pop())&amp;&amp;void 0!==r?r:"";<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(l[d]=e)}</span>c</span>onst b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var n;<span class="cstat-no" title="statement not covered" >if(!e||"string"==typeof e||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"undefined"!=typeof FormData&amp;&amp;e instanceof FormData}</span>(e)||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"undefined"!=typeof URLSearchParams&amp;&amp;e instanceof URLSearchParams}</span>(e)||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return ks(e,"ArrayBuffer")}</span>(e)||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return ks(e,"File")}</span>(e)||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return ks(e,"Blob")}</span>(e)||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"undefined"!=typeof ReadableStream&amp;&amp;e instanceof ReadableStream}</span>(e))<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"undefined"!=typeof ArrayBuffer&amp;&amp;ArrayBuffer.isView(e)}</span>(e))<span class="cstat-no" title="statement not covered" >return e.buffer;<span class="cstat-no" title="statement not covered" >i</span></span>f("object"==typeof e)<span class="cstat-no" title="statement not covered" >return t["content-type"]=null!==(n=t["content-type"])&amp;&amp;void 0!==n?n:"application/json;charset=utf-8",JSON.stringify(e);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new TypeError("Unknown body type")}</span>(i,l),</span>p=<span class="cstat-no" title="statement not covered" >Object.assign(Object.assign({},s),{url:u,headers:l,body:b});</span>let m;<span class="cstat-no" title="statement not covered" >m=t.createXHR?t.createXHR():new XMLHttpRequest;{</span>const{progressSubscriber:n,includeDownloadProgress:r=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>includeUploadProgress:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >m.addEventListener(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var t;const s=<span class="cstat-no" title="statement not covered" >r();<span class="cstat-no" title="statement not covered" ></span>null===(t=null==n?void 0:n.error)||void 0===t||t.call(n,s),e.error(s)}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>o("timeout",(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new ms(m,p))</span>),o("abort",(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new ps("aborted",m,p))</span>);c</span>onst i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >new bs(t,m,p,`${e}_${t.type}`),</span></span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,n,r)=&gt;{<span class="cstat-no" title="statement not covered" >t.addEventListener(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.next(i(r,t))}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;[Os,Ts,As].forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >c(m.upload,e,"upload"))</span>),n&amp;&amp;[Os,Ts].forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >m.upload.addEventListener(e,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{var t;<span class="cstat-no" title="statement not covered" >return null===(t=null==n?void 0:n.next)||void 0===t?void 0:t.call(n,e)}</span>)))</span>),r&amp;&amp;[Os,Ts].forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >c(m,e,"download"))</span>);c</span>onst u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >"ajax error"+(t?" "+t:"");<span class="cstat-no" title="statement not covered" ></span>e.error(new ps(n,m,p))}</span>;<span class="cstat-no" title="statement not covered" ></span>m.addEventListener("error",(<span class="fstat-no" title="function not covered" >e=</span>&gt;{var t;<span class="cstat-no" title="statement not covered" >null===(t=null==n?void 0:n.error)||void 0===t||t.call(n,e),u()}</span>)),m.addEventListener(As,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{var r,s;const{status:o}=<span class="cstat-no" title="statement not covered" >m;<span class="cstat-no" title="statement not covered" ></span>if(o&lt;400){let s;<span class="cstat-no" title="statement not covered" >null===(r=null==n?void 0:n.complete)||void 0===r||r.call(n);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >s=i("download",t)}</span>catch(t){<span class="cstat-no" title="statement not covered" >return void e.error(t)}<span class="cstat-no" title="statement not covered" ></span>e</span>.next(s),e.complete()}</span>else <span class="cstat-no" title="statement not covered" >null===(s=null==n?void 0:n.error)||void 0===s||s.call(n,t),u(o)}</span></span>))}</span>const{user:v,method:w,async:y}=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>v?m.open(w,u,y,v,p.password):m.open(w,u,y),y&amp;&amp;(m.timeout=p.timeout,m.responseType=p.responseType),"withCredentials"in m&amp;&amp;(m.withCredentials=p.withCredentials);<span class="cstat-no" title="statement not covered" >f</span>or(const e in l)<span class="cstat-no" title="statement not covered" >l.hasOwnProperty(e)&amp;&amp;m.setRequestHeader(e,l[e]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn b?m.send(b):m.send(),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >m&amp;&amp;4!==m.readyState&amp;&amp;m.abort()}</span>}</span>));v</span>ar t};return e.get=vs,e.post=ws,e.delete=ys,e.put=xs,e.patch=_s,e.getJSON=Ss,e})(),Os="loadstart",Ts="progress",As="load";const Is=Object.prototype.toString;function <span class="fstat-no" title="function not covered" >ks(</span>e,t){<span class="cstat-no" title="statement not covered" >return Is.call(e)===`[object ${t}]`}</span>function <span class="fstat-no" title="function not covered" >js(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const{selector:n}=<span class="cstat-no" title="statement not covered" >t,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(var r in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,r)&amp;&amp;t.indexOf(r)&lt;0&amp;&amp;(n[r]=e[r]);<span class="cstat-no" title="statement not covered" >i</span></span>f(null!=e&amp;&amp;"function"==typeof Object.getOwnPropertySymbols){var s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(r=Object.getOwnPropertySymbols(e);s&lt;r.length;s++)<span class="cstat-no" title="statement not covered" >t.indexOf(r[s])&lt;0&amp;&amp;Object.prototype.propertyIsEnumerable.call(e,r[s])&amp;&amp;(n[r[s]]=e[r[s]])}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn n}</span>(t,["selector"]);<span class="cstat-no" title="statement not covered" ></span>return new j((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >new AbortController,</span>{signal:o}=<span class="cstat-no" title="statement not covered" >s;</span>let i=<span class="cstat-no" title="statement not covered" >!0;</span>const{signal:c}=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>if(c)<span class="cstat-no" title="statement not covered" >if(c.aborted)<span class="cstat-no" title="statement not covered" >s.abort();e</span>lse{const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o.aborted||s.abort()}</span>;<span class="cstat-no" title="statement not covered" ></span>c.addEventListener("abort",e),t.add((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >c.removeEventListener("abort",e))</span>)}</span>c</span></span>onst u=<span class="cstat-no" title="statement not covered" >Object.assign(Object.assign({},r),{signal:o}),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >i=!1,t.error(e)}</span>;<span class="cstat-no" title="statement not covered" ></span>return fetch(e,u).then((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >n?De(n(e)).subscribe(F(t,void 0,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i=!1,t.complete()}</span>),l)):(i=!1,t.next(e),t.complete())}</span>)).catch(l),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i&amp;&amp;s.abort()}</span>}</span>))}</span>const Cs={url:"",deserializer:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >JSON.parse(e.data),</span>serializer:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >JSON.stringify(e)}</span>;class Ps extends ${<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >if(super(),this._socket=null,e instanceof j)<span class="cstat-no" title="statement not covered" >this.destination=t,this.source=e;e</span>lse{const t=<span class="cstat-no" title="statement not covered" >this._config=Object.assign({},Cs);<span class="cstat-no" title="statement not covered" ></span>if(this._output=new V,"string"==typeof e)<span class="cstat-no" title="statement not covered" >t.url=e;e</span>lse <span class="cstat-no" title="statement not covered" >for(const n in e)<span class="cstat-no" title="statement not covered" >e.hasOwnProperty(n)&amp;&amp;(t[n]=e[n]);<span class="cstat-no" title="statement not covered" >i</span></span></span>f(!t.WebSocketCtor&amp;&amp;WebSocket)<span class="cstat-no" title="statement not covered" >t.WebSocketCtor=WebSocket;e</span>lse <span class="cstat-no" title="statement not covered" >if(!t.WebSocketCtor)<span class="cstat-no" title="statement not covered" >throw new Error("no WebSocket constructor can be found");<span class="cstat-no" title="statement not covered" >t</span></span></span>his.destination=new Y}</span>}<span class="fstat-no" title="function not covered" ></span>li</span>ft(e){const t=<span class="cstat-no" title="statement not covered" >new Ps(this._config,this.destination);<span class="cstat-no" title="statement not covered" ></span>return t.operator=e,t.source=this,t}<span class="fstat-no" title="function not covered" ></span>_r</span>esetState(){<span class="cstat-no" title="statement not covered" >this._socket=null,this.source||(this.destination=new Y),this._output=new V}<span class="fstat-no" title="function not covered" ></span>mu</span>ltiplex(e,t,n){const r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return new j((<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r.next(e())}</span>catch(e){<span class="cstat-no" title="statement not covered" >s.error(e)}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >r.subscribe({next:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >n(e)&amp;&amp;s.next(e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >s.error(e)}</span>}</span>,error:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >s.error(e),</span>complete:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s.complete()}</span>);<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r.next(t())}</span>catch(e){<span class="cstat-no" title="statement not covered" >s.error(e)}<span class="cstat-no" title="statement not covered" ></span>o</span>.unsubscribe()}</span>}</span>))}<span class="fstat-no" title="function not covered" ></span>_c</span>onnectSocket(){const{WebSocketCtor:e,protocol:t,url:n,binaryType:r}=<span class="cstat-no" title="statement not covered" >this._config,</span>o=<span class="cstat-no" title="statement not covered" >this._output;</span>let i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >i=t?new e(n,t):new e(n),this._socket=i,r&amp;&amp;(this._socket.binaryType=r)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return void o.error(e)}</span>c</span>onst c=<span class="cstat-no" title="statement not covered" >new s((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._socket=null,i&amp;&amp;1===i.readyState&amp;&amp;i.close()}</span>));<span class="cstat-no" title="statement not covered" ></span>i.onopen=<span class="fstat-no" title="function not covered" >e=</span>&gt;{const{_socket:t}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return i.close(),void this._resetState();c</span></span>onst{openObserver:n}=<span class="cstat-no" title="statement not covered" >this._config;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n.next(e);c</span>onst r=<span class="cstat-no" title="statement not covered" >this.destination;<span class="cstat-no" title="statement not covered" ></span>this.destination=w.create((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(1===i.readyState)<span class="cstat-no" title="statement not covered" >try{const{serializer:t}=<span class="cstat-no" title="statement not covered" >this._config;<span class="cstat-no" title="statement not covered" ></span>i.send(t(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >this.destination.error(e)}</span>}</span></span>),(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const{closingObserver:t}=<span class="cstat-no" title="statement not covered" >this._config;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;t.next(void 0),e&amp;&amp;e.code?i.close(e.code,e.reason):o.error(new TypeError("WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }")),this._resetState()}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const{closingObserver:e}=<span class="cstat-no" title="statement not covered" >this._config;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.next(void 0),i.close(),this._resetState()}</span>)),r&amp;&amp;r instanceof Y&amp;&amp;c.add(r.subscribe(this.destination))}</span>,i.onerror=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._resetState(),o.error(e)}</span>,i.onclose=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >i===this._socket&amp;&amp;this._resetState();c</span>onst{closeObserver:t}=<span class="cstat-no" title="statement not covered" >this._config;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;t.next(e),e.wasClean?o.complete():o.error(e)}</span>,i.onmessage=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >try{const{deserializer:t}=<span class="cstat-no" title="statement not covered" >this._config;<span class="cstat-no" title="statement not covered" ></span>o.next(t(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o.error(e)}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>_s</span>ubscribe(e){const{source:t}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t?t.subscribe(e):(this._socket||this._connectSocket(),this._output.subscribe(e),e.add((<span class="fstat-no" title="function not covered" >()</span>=&gt;{const{_socket:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>0===this._output.observers.length&amp;&amp;(!e||1!==e.readyState&amp;&amp;0!==e.readyState||e.close(),this._resetState())}</span>)),e)}<span class="fstat-no" title="function not covered" ></span>un</span>subscribe(){const{_socket:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>!e||1!==e.readyState&amp;&amp;0!==e.readyState||e.close(),this._resetState(),super.unsubscribe()}</span>}function <span class="fstat-no" title="function not covered" >Ns(</span>e){<span class="cstat-no" title="statement not covered" >return new Ps(e)}</span>function <span class="fstat-no" title="function not covered" >Fs(</span>e,t){<span class="cstat-no" title="statement not covered" >for(let n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >t.length;</span>n&lt;r;n++){const r=<span class="cstat-no" title="statement not covered" >t[n],</span>s=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyNames(r.prototype);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >s.length;</span>t&lt;n;t++){const n=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>e.prototype[n]=r.prototype[n]}</span>}</span>}</span>export{xe as $,J as A,B,f as C,I as D,h as E,A as F,et as G,nt as H,rt as I,st as J,tt as K,ot as L,M,Ke as N,j as O,it as P,pt as Q,Y as R,s as S,ut as T,n as U,ve as V,mt as W,St as X,jt as Y,Nt as Z,Ct as _,Fs as a,or as a$,Ft as a0,Ye as a1,zt as a2,Dt as a3,Ht as a4,Wt as a5,Vt as a6,$t as a7,Xt as a8,Je as a9,On as aA,An as aB,kn as aC,jn as aD,Cn as aE,Pn as aF,Nn as aG,zn as aH,Rn as aI,Un as aJ,Dn as aK,Hn as aL,Mn as aM,Bn as aN,Xn as aO,Yn as aP,Zn as aQ,Gn as aR,Jn as aS,Kn as aT,Qt as aU,Qn as aV,er as aW,nr as aX,rr as aY,sr as aZ,qn as a_,Gt as aa,Zt as ab,en as ac,tn as ad,rn as ae,Ge as af,Mt as ag,sn as ah,on as ai,Xe as aj,ye as ak,Bt as al,u as am,cn as an,un as ao,ln as ap,an as aq,hn as ar,fn as as,dn as at,bn as au,_n as av,xn as aw,Sn as ax,kt as ay,En as az,V as b,cs as b$,cr as b0,ht as b1,Ln as b2,ur as b3,lr as b4,It as b5,ar as b6,At as b7,hr as b8,fr as b9,Ur as bA,Dr as bB,Hr as bC,Wr as bD,Ve as bE,Vr as bF,Mr as bG,$r as bH,Br as bI,Fn as bJ,ir as bK,Xr as bL,Yr as bM,Jr as bN,Gr as bO,Zr as bP,Vn as bQ,Kr as bR,lt as bS,es as bT,ts as bU,wn as bV,ns as bW,rs as bX,ss as bY,os as bZ,is as b_,br as ba,pr as bb,mr as bc,Me as bd,vr as be,yr as bf,xr as bg,_r as bh,gr as bi,Sr as bj,Er as bk,Or as bl,mn as bm,Tr as bn,Ar as bo,Ir as bp,kr as bq,L as br,jr as bs,Cr as bt,Pr as bu,Nr as bv,Fr as bw,Lr as bx,Rr as by,zr as bz,we as c,us as c0,as as c1,gn as c2,Tn as c3,dr as c4,wr as c5,hs as c6,fs as c7,ls as c8,Es as c9,ps as ca,ms as cb,bs as cc,js as cd,Ns as ce,Ps as cf,U as d,d as e,X as f,Z as g,R as h,ie as i,T as j,D as k,ae as l,le as m,b as n,Qe as o,z as p,fe as q,he as r,be as s,l as t,de as u,me as v,pe as w,ce as x,w as y,Ze as z};
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2023-08-09T02:23:52.200Z
            </div>
        <script src="../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../sorter.js"></script>
        <script src="../../block-navigation.js"></script>
    </body>
</html>
    